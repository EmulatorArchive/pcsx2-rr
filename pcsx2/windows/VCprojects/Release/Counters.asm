; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	f:\Emu\ps2\src\pcsx2\Counters.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?GetVersion@SaveState@@QBEIXZ			; SaveState::GetVersion
PUBLIC	?IsLoading@SaveState@@QBE_NXZ			; SaveState::IsLoading
PUBLIC	??$Freeze@$$BY05UCounter@@@SaveState@@QAEXAAY05UCounter@@@Z ; SaveState::Freeze<Counter [6]>
PUBLIC	??$Freeze@I@SaveState@@QAEXAAI@Z		; SaveState::Freeze<unsigned int>
PUBLIC	?counters@@3PAUCounter@@A			; counters
PUBLIC	?g_vu1SkipCount@@3IA				; g_vu1SkipCount
PUBLIC	?g_nCounters@@3PAHA				; g_nCounters
PUBLIC	?nextCounter@@3HA				; nextCounter
PUBLIC	?nextsCounter@@3IA				; nextsCounter
PUBLIC	?gates@@3HA					; gates
PUBLIC	??_C@_0DH@NFFNMMLL@Framelimiter?5rate?5updated?5?$CIUpdat@ ; `string'
?counters@@3PAUCounter@@A DB 0f0H DUP (?)		; counters
?g_vu1SkipCount@@3IA DD 01H DUP (?)			; g_vu1SkipCount
?g_nCounters@@3PAHA DD 04H DUP (?)			; g_nCounters
?nextCounter@@3HA DD 01H DUP (?)			; nextCounter
?nextsCounter@@3IA DD 01H DUP (?)			; nextsCounter
?gates@@3HA DD	01H DUP (?)				; gates
_iFrame	DD	01H DUP (?)
	ALIGN	8

_m_iTicks DQ	01H DUP (?)
_m_iStart DQ	01H DUP (?)
;	COMDAT ??_C@_0DH@NFFNMMLL@Framelimiter?5rate?5updated?5?$CIUpdat@
CONST	SEGMENT
??_C@_0DH@NFFNMMLL@Framelimiter?5rate?5updated?5?$CIUpdat@ DB 'Framelimit'
	DB	'er rate updated (UpdateVSyncRate): %d.%d fps', 00H ; `string'
	ORG $+169196
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\windows\memzero.h
_TEXT	SEGMENT
_dest$ = 8						; size = 4
??$memzero_ptr@$0PA@@@YAXPAX@Z PROC			; memzero_ptr<240>

; 50   : {

	push	edi

; 238  : 			{
; 239  : 				cld;

	cld

; 240  : 				mov ecx, remdat

	mov	ecx, 60					; 0000003cH

; 241  : 				mov edi, dest

	mov	edi, DWORD PTR _dest$[esp]

; 242  : 				xor eax, eax

	xor	eax, eax

; 243  : 				rep stosd

	rep	 stosd

; 51   : 	if( bytes == 0 ) return;
; 52   : 
; 53   : 	// This function only works on 32-bit alignments.  For anything else we just fall back
; 54   : 	// on the compiler-provided implementation of memset...
; 55   : 
; 56   : 	if( (bytes & 0x3) != 0 )
; 57   : 	{
; 58   : 		memset( dest, 0, bytes );
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	enum
; 63   : 	{
; 64   : 		remainder = bytes & 127,
; 65   : 		bytes128 = bytes / 128
; 66   : 	};
; 67   : 
; 68   : 	// Initial check -- if the length is not a multiple of 16 then fall back on
; 69   : 	// using rep movsd methods.  Handling these unaligned clears in a more efficient
; 70   : 	// manner isn't necessary in pcsx2 (meaning they aren't used in speed-critical
; 71   : 	// scenarios).
; 72   : 
; 73   : 	if( (bytes & 0xf) == 0 )
; 74   : 	{
; 75   : 		u64 _xmm_backup[2];
; 76   : 
; 77   : 		if( ((uptr)dest & 0xf) != 0 )
; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;
; 87   : 					mov ecx,dest
; 88   : 					pxor xmm0,xmm0
; 89   : 					mov eax,bytes128
; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;
; 95   : 					movups [ecx+0x10],xmm0;
; 96   : 					movups [ecx+0x20],xmm0;
; 97   : 					movups [ecx+0x30],xmm0;
; 98   : 					movups [ecx+0x40],xmm0;
; 99   : 					movups [ecx+0x50],xmm0;
; 100  : 					movups [ecx+0x60],xmm0;
; 101  : 					movups [ecx+0x70],xmm0;
; 102  : 					sub ecx,-128
; 103  : 					dec eax;
; 104  : 					jnz _loop_6;
; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];
; 122  : 				}
; 123  : 				return;
; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;
; 135  : 				mov ecx,dest
; 136  : 				pxor xmm0,xmm0
; 137  : 				mov eax,bytes128
; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;
; 143  : 				movaps [ecx+0x10],xmm0;
; 144  : 				movaps [ecx+0x20],xmm0;
; 145  : 				movaps [ecx+0x30],xmm0;
; 146  : 				movaps [ecx+0x40],xmm0;
; 147  : 				movaps [ecx+0x50],xmm0;
; 148  : 				movaps [ecx+0x60],xmm0;
; 149  : 				movaps [ecx+0x70],xmm0;
; 150  : 				sub ecx,-128
; 151  : 				dec eax;
; 152  : 				jnz _loop_8;
; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];
; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm

	pop	edi

; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	ret	0
??$memzero_ptr@$0PA@@@YAXPAX@Z ENDP			; memzero_ptr<240>
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\savestate.h
_TEXT	ENDS
;	COMDAT ??$Freeze@I@SaveState@@QAEXAAI@Z
_TEXT	SEGMENT
??$Freeze@I@SaveState@@QAEXAAI@Z PROC			; SaveState::Freeze<unsigned int>, COMDAT
; _this$ = ecx
; _data$ = edx

; 72   : 		FreezeMem( &data, sizeof( T ) );

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	push	4
	push	edx
	call	eax

; 73   : 	}

	ret	0
??$Freeze@I@SaveState@@QAEXAAI@Z ENDP			; SaveState::Freeze<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$Freeze@$$BY05UCounter@@@SaveState@@QAEXAAY05UCounter@@@Z
_TEXT	SEGMENT
??$Freeze@$$BY05UCounter@@@SaveState@@QAEXAAY05UCounter@@@Z PROC ; SaveState::Freeze<Counter [6]>, COMDAT
; _this$ = ecx

; 72   : 		FreezeMem( &data, sizeof( T ) );

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	240					; 000000f0H
	push	OFFSET ?counters@@3PAUCounter@@A	; counters
	call	edx

; 73   : 	}

	ret	0
??$Freeze@$$BY05UCounter@@@SaveState@@QAEXAAY05UCounter@@@Z ENDP ; SaveState::Freeze<Counter [6]>
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\windows\memzero.h
_TEXT	ENDS
_TEXT	SEGMENT
_object$ = 8						; size = 4
??$memzero_obj@$$BY05UCounter@@@@YAXAAY05UCounter@@@Z PROC ; memzero_obj<Counter [6]>

; 572  : {

	push	edi

; 573  : 	memzero_ptr<sizeof(T)>( &object );

	cld
	mov	ecx, 60					; 0000003cH
	mov	edi, DWORD PTR _object$[esp]
	xor	eax, eax
	rep	 stosd
	pop	edi

; 574  : }

	ret	0
??$memzero_obj@$$BY05UCounter@@@@YAXAAY05UCounter@@@Z ENDP ; memzero_obj<Counter [6]>
_TEXT	ENDS
PUBLIC	?rcntCycle@@YIIH@Z				; rcntCycle
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\counters.cpp
_TEXT	SEGMENT
?rcntCycle@@YIIH@Z PROC					; rcntCycle
; _index$ = eax

; 837  : 	if (counters[index].mode.IsCounting && (counters[index].mode.ClockSource != 0x3)) 

	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+ecx+4]
	add	ecx, ecx
	test	al, al
	jns	SHORT $LN2@rcntCycle
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN2@rcntCycle

; 838  : 		return counters[index].count + ((cpuRegs.cycle - counters[index].sCycleT) / counters[index].rate);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+36]
	xor	edx, edx
	div	DWORD PTR ?counters@@3PAUCounter@@A[ecx+16]
	add	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx]

; 841  : }

	ret	0
$LN2@rcntCycle:

; 839  : 	else 
; 840  : 		return counters[index].count;

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx]

; 841  : }

	ret	0
?rcntCycle@@YIIH@Z ENDP					; rcntCycle
_TEXT	ENDS
PUBLIC	?rcntRcount@@YIIH@Z				; rcntRcount
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?rcntRcount@@YIIH@Z PROC				; rcntRcount
; _index$ = ecx

; 823  : 	u32 ret;
; 824  : 
; 825  : 	// only count if the counter is turned on (0x80) and is not an hsync gate (!0x03)
; 826  : 	if (counters[index].mode.IsCounting && (counters[index].mode.ClockSource != 0x3)) 

	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+ecx+4]
	add	ecx, ecx
	test	al, al
	jns	SHORT $LN2@rcntRcount
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN2@rcntRcount

; 827  : 		ret = counters[index].count + ((cpuRegs.cycle - counters[index].sCycleT) / counters[index].rate);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+36]
	xor	edx, edx
	div	DWORD PTR ?counters@@3PAUCounter@@A[ecx+16]
	add	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx]

; 833  : }

	ret	0
$LN2@rcntRcount:

; 828  : 	else 
; 829  : 		ret = counters[index].count;
; 830  : 
; 831  : 	EECNT_LOG("EE Counter[%d] readCount32 = %x\n", index, ret);
; 832  : 	return ret;

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx]

; 833  : }

	ret	0
?rcntRcount@@YIIH@Z ENDP				; rcntRcount
_TEXT	ENDS
PUBLIC	?rcntWhold@@YIXHI@Z				; rcntWhold
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?rcntWhold@@YIXHI@Z PROC				; rcntWhold
; _index$ = ecx
; _value$ = edx

; 817  : 	EECNT_LOG("EE Counter[%d] Hold Write = %x\n", index, value);
; 818  : 	counters[index].hold = value;

	lea	eax, DWORD PTR [ecx+ecx*4]
	mov	DWORD PTR ?counters@@3PAUCounter@@A[eax*8+12], edx

; 819  : }

	ret	0
?rcntWhold@@YIXHI@Z ENDP				; rcntWhold
_TEXT	ENDS
PUBLIC	?rcntEndGate@@YIX_NI@Z				; rcntEndGate
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_isVblank$ = 8						; size = 1
?rcntEndGate@@YIX_NI@Z PROC				; rcntEndGate
; _sCycle$ = edi

; 702  : {

	push	ebx
	push	esi

; 703  : 	int i;
; 704  : 
; 705  : 	for(i=0; i <=3; i++) { //Gates for counters

	mov	esi, 1
	mov	ecx, OFFSET ?counters@@3PAUCounter@@A+4
	npad	4
$LL20@rcntEndGat:

; 706  : 		if (!(gates & (1<<i))) continue;

	mov	eax, DWORD PTR ?gates@@3HA		; gates
	test	esi, eax
	je	SHORT $LN9@rcntEndGat

; 707  : 		if ((!!counters[i].mode.GateSource) != isVblank) continue;

	mov	ebx, DWORD PTR [ecx]
	mov	edx, ebx
	shr	edx, 3
	and	edx, 1
	cmp	dl, BYTE PTR _isVblank$[esp+4]
	jne	SHORT $LN9@rcntEndGat

; 708  : 
; 709  : 		switch (counters[i].mode.GateMode) {

	mov	eax, ebx
	shr	eax, 4
	and	eax, 3
	je	SHORT $LN3@rcntEndGat
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN9@rcntEndGat

; 719  : 				EECNT_LOG("EE Counter[%d] %s EndGate Type0, count = %x\n",
; 720  : 					isVblank ? "vblank" : "hblank", i, counters[i].count );
; 721  : 			break;
; 722  : 
; 723  : 			case 0x1:	// Reset and start counting on Vsync start
; 724  : 				// this is the vsync end so do nothing
; 725  : 			break;
; 726  : 
; 727  : 			case 0x2: //Reset and start counting on Vsync end
; 728  : 			case 0x3: //Reset and start counting on Vsync start and end
; 729  : 				counters[i].mode.IsCounting = 1;

	or	ebx, 128				; 00000080H

; 730  : 				counters[i].count = 0;
; 731  : 				counters[i].target &= 0xffff;

	xor	eax, eax
	mov	DWORD PTR [ecx-4], 0
	mov	WORD PTR [ecx+6], ax

; 732  : 				counters[i].sCycleT = sCycle;
; 733  : 				EECNT_LOG("EE Counter[%d] %s EndGate Type%d, count = %x\n",
; 734  : 					isVblank ? "vblank" : "hblank", i, counters[i].mode.GateMode, counters[i].count );
; 735  : 			break;

	jmp	SHORT $LN21@rcntEndGat
$LN3@rcntEndGat:

; 710  : 			case 0x0: //Count When Signal is low (off)
; 711  : 
; 712  : 				// Set the count here.  Since the timer is being turned off it's
; 713  : 				// important to record its count at this point (it won't be counted by
; 714  : 				// calls to rcntUpdate).
; 715  : 
; 716  : 				counters[i].count = rcntRcount(i);

	test	bl, bl
	jns	SHORT $LN14@rcntEndGat
	mov	edx, ebx
	and	edx, 3
	cmp	dl, 3
	je	SHORT $LN14@rcntEndGat
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	eax, DWORD PTR [ecx+32]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	add	eax, DWORD PTR [ecx-4]
	jmp	SHORT $LN13@rcntEndGat
$LN14@rcntEndGat:
	mov	eax, DWORD PTR [ecx-4]
$LN13@rcntEndGat:
	mov	DWORD PTR [ecx-4], eax

; 717  : 				counters[i].mode.IsCounting = 0;

	and	ebx, -129				; ffffff7fH
$LN21@rcntEndGat:

; 718  : 				counters[i].sCycleT = sCycle;

	mov	DWORD PTR [ecx+32], edi
	mov	DWORD PTR [ecx], ebx
$LN9@rcntEndGat:
	add	ecx, 40					; 00000028H
	rol	esi, 1
	cmp	ecx, OFFSET ?counters@@3PAUCounter@@A+124
	jle	SHORT $LL20@rcntEndGat
	pop	esi
	pop	ebx

; 736  : 		}
; 737  : 	}
; 738  : 	// Note: No need to set counters here.  They'll get set when control returns to
; 739  : 	// rcntUpdate, since we're being called from there anyway.
; 740  : }

	ret	4
?rcntEndGate@@YIX_NI@Z ENDP				; rcntEndGate
_TEXT	ENDS
PUBLIC	?vSyncDebugStuff@@YAXXZ				; vSyncDebugStuff
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?vSyncDebugStuff@@YAXXZ PROC				; vSyncDebugStuff

; 275  : 
; 276  : #ifdef PCSX2_DEVBUILD
; 277  : 		if( g_TestRun.enabled && g_TestRun.frame > 0 ) {
; 278  : 			if( iFrame > g_TestRun.frame ) {
; 279  : 				// take a snapshot
; 280  : 				if( g_TestRun.pimagename != NULL && GSmakeSnapshot2 != NULL ) {
; 281  : 					if( g_TestRun.snapdone ) {
; 282  : 						g_TestRun.curimage++;
; 283  : 						g_TestRun.snapdone = 0;
; 284  : 						g_TestRun.frame += 20;
; 285  : 						if( g_TestRun.curimage >= g_TestRun.numimages ) {
; 286  : 							// exit
; 287  : 							SysClose();
; 288  : 							exit(0);
; 289  : 						}
; 290  : 					}
; 291  : 					else {
; 292  : 						// query for the image
; 293  : 						GSmakeSnapshot2(g_TestRun.pimagename, &g_TestRun.snapdone, g_TestRun.jpgcapture);
; 294  : 					}
; 295  : 				}
; 296  : 				else {
; 297  : 					// exit
; 298  : 					SysClose();
; 299  : 					exit(0);
; 300  : 				}
; 301  : 			}
; 302  : 		}
; 303  : 
; 304  : 		GSVSYNC();
; 305  : 
; 306  : 		if( g_SaveGSStream == 1 ) {
; 307  : 			freezeData fP;
; 308  : 
; 309  : 			g_SaveGSStream = 2;
; 310  : 			g_fGSSave->gsFreeze();
; 311  : 			
; 312  : 			if (GSfreeze(FREEZE_SIZE, &fP) == -1) {
; 313  : 				safe_delete( g_fGSSave );
; 314  : 				g_SaveGSStream = 0;
; 315  : 			}
; 316  : 			else {
; 317  : 				fP.data = (s8*)malloc(fP.size);
; 318  : 				if (fP.data == NULL) {
; 319  : 					safe_delete( g_fGSSave );
; 320  : 					g_SaveGSStream = 0;
; 321  : 				}
; 322  : 				else {
; 323  : 					if (GSfreeze(FREEZE_SAVE, &fP) == -1) {
; 324  : 						safe_delete( g_fGSSave );
; 325  : 						g_SaveGSStream = 0;
; 326  : 					}
; 327  : 					else {
; 328  : 						g_fGSSave->Freeze( fP.size );
; 329  : 						if (fP.size) {
; 330  : 							g_fGSSave->FreezeMem( fP.data, fP.size );
; 331  : 							free(fP.data);
; 332  : 						}
; 333  : 					}
; 334  : 				}
; 335  : 			}
; 336  : 		}
; 337  : 		else if( g_SaveGSStream == 2 ) {
; 338  : 			
; 339  : 			if( --g_nLeftGSFrames <= 0 ) {
; 340  : 				safe_delete( g_fGSSave );
; 341  : 				g_SaveGSStream = 0;
; 342  : 				Console::WriteLn("Done saving GS stream");
; 343  : 			}
; 344  : 		}
; 345  : #endif
; 346  : }

	ret	0
?vSyncDebugStuff@@YAXXZ ENDP				; vSyncDebugStuff
; Function compile flags: /Ogtpy
tv207 = -40						; size = 4
tv211 = -36						; size = 4
_hRender$ = -32						; size = 8
tv193 = -24						; size = 8
_Render$ = -24						; size = 8
tv176 = -16						; size = 8
tv81 = -16						; size = 8
_Blank$ = -16						; size = 8
tv69 = -8						; size = 8
_hBlank$ = -8						; size = 8
tv203 = 8						; size = 4
_framesPerSecond$ = 8					; size = 4
_scansPerFrame$ = 12					; size = 4
?vSyncInfoCalc@@YAXPAUvSyncTimingInfo@@II@Z PROC	; vSyncInfoCalc
; _info$ = edi

; 166  : {

	sub	esp, 40					; 00000028H

; 167  : 	// Important: Cannot use floats or doubles here.  The emulator changes rounding modes
; 168  : 	// depending on user-set speedhack options, and it can break float/double code
; 169  : 	// (as in returning infinities and junk)
; 170  : 
; 171  : 	// NOTE: mgs3 likes a /4 vsync, but many games prefer /2.  This seems to indicate a
; 172  : 	// problem in the counters vsync gates somewhere.
; 173  : 
; 174  : 	u64 Frame = ((u64)PS2CLK * 1000000ULL) / framesPerSecond;

	mov	eax, DWORD PTR _framesPerSecond$[esp+36]
	push	ebx
	push	ebp
	push	esi
	push	0
	push	eax
	push	68664					; 00010c38H
	push	-1929379840				; 8d000000H
	call	__aulldiv

; 175  : 	u64 HalfFrame = Frame / 2;

	mov	ecx, edx
	mov	ebx, eax
	shrd	ebx, ecx, 1
	shr	ecx, 1

; 176  : 	u64 Blank = HalfFrame / 2;		// two blanks and renders per frame

	mov	esi, ecx
	mov	ebp, ebx
	shrd	ebp, esi, 1
	shr	esi, 1

; 177  : 	u64 Render = HalfFrame - Blank;	// so use the half-frame value for these...

	sub	ebx, ebp
	sbb	ecx, esi

; 178  : 
; 179  : 	// Important!  The hRender/hBlank timers should be 50/50 for best results.
; 180  : 	// In theory a 70%/30% ratio would be more correct but in practice it runs
; 181  : 	// like crap and totally screws audio synchronization and other things.
; 182  : 	
; 183  : 	u64 Scanline = Frame / scansPerFrame;

	push	0
	mov	DWORD PTR _Render$[esp+60], ecx
	mov	ecx, DWORD PTR _scansPerFrame$[esp+52]
	push	ecx
	push	edx
	mov	DWORD PTR _Blank$[esp+64], ebp
	push	eax
	mov	ebp, ebx
	call	__aulldiv

; 184  : 	u64 hBlank = Scanline / 2;

	mov	ebx, edx
	mov	ecx, eax
	shrd	ecx, ebx, 1
	shr	ebx, 1

; 185  : 	u64 hRender = Scanline - hBlank;

	sub	eax, ecx

; 186  : 	
; 187  : 	info->Framerate = framesPerSecond;
; 188  : 	info->Render = (u32)(Render/10000);

	push	0
	sbb	edx, ebx
	mov	DWORD PTR _hRender$[esp+56], eax
	mov	eax, DWORD PTR _Render$[esp+60]
	push	10000					; 00002710H
	mov	DWORD PTR _hRender$[esp+64], edx
	mov	edx, DWORD PTR _framesPerSecond$[esp+56]
	push	eax
	push	ebp
	mov	DWORD PTR _hBlank$[esp+68], ecx
	mov	DWORD PTR [edi], edx
	call	__aulldiv

; 189  : 	info->Blank  = (u32)(Blank/10000);

	mov	ecx, DWORD PTR _Blank$[esp+52]
	push	0
	push	10000					; 00002710H
	push	esi
	push	ecx
	mov	DWORD PTR tv203[esp+64], eax
	mov	DWORD PTR [edi+4], eax
	call	__aulldiv

; 190  : 
; 191  : 	info->hRender = (u32)(hRender/10000);

	mov	edx, DWORD PTR _hRender$[esp+56]
	push	0
	push	10000					; 00002710H
	mov	DWORD PTR tv207[esp+60], eax
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR _hRender$[esp+60]
	push	edx
	push	eax
	call	__aulldiv

; 192  : 	info->hBlank  = (u32)(hBlank/10000);

	mov	ecx, DWORD PTR _hBlank$[esp+52]
	push	0
	push	10000					; 00002710H
	push	ebx
	push	ecx
	mov	DWORD PTR tv211[esp+68], eax
	mov	DWORD PTR [edi+16], eax
	call	__aulldiv

; 193  : 	info->hScanlinesPerFrame = scansPerFrame;

	mov	edx, DWORD PTR _scansPerFrame$[esp+48]

; 194  : 	
; 195  : 	// Apply rounding:
; 196  : 	if( ( Render - info->Render ) >= 5000 ) info->Render++;

	mov	ecx, DWORD PTR _Render$[esp+56]
	mov	DWORD PTR [edi+24], edx
	xor	edx, edx
	sub	ebp, DWORD PTR tv203[esp+48]
	mov	DWORD PTR [edi+20], eax
	sbb	ecx, edx
	mov	DWORD PTR tv193[esp+56], ecx
	jne	SHORT $LN9@vSyncInfoC
	cmp	ebp, 5000				; 00001388H
	jb	SHORT $LN6@vSyncInfoC
$LN9@vSyncInfoC:
	mov	ecx, DWORD PTR tv203[esp+48]
	inc	ecx
	mov	DWORD PTR [edi+4], ecx
	jmp	SHORT $LN4@vSyncInfoC
$LN6@vSyncInfoC:

; 197  : 	else if( ( Blank - info->Blank ) >= 5000 ) info->Blank++;

	mov	ecx, DWORD PTR _Blank$[esp+52]
	mov	edx, DWORD PTR tv207[esp+52]
	xor	ebp, ebp
	sub	ecx, edx
	sbb	esi, ebp
	mov	DWORD PTR tv176[esp+56], esi
	jne	SHORT $LN10@vSyncInfoC
	cmp	ecx, 5000				; 00001388H
	jb	SHORT $LN4@vSyncInfoC
$LN10@vSyncInfoC:
	inc	edx
	mov	DWORD PTR [edi+8], edx
$LN4@vSyncInfoC:

; 198  : 
; 199  : 	if( ( hRender - info->hRender ) >= 5000 ) info->hRender++;

	mov	ecx, DWORD PTR _hRender$[esp+52]
	mov	esi, DWORD PTR tv211[esp+52]
	mov	edx, DWORD PTR _hRender$[esp+56]
	xor	ebp, ebp
	sub	ecx, esi
	sbb	edx, ebp
	mov	DWORD PTR tv81[esp+56], edx
	jne	SHORT $LN11@vSyncInfoC
	cmp	ecx, 5000				; 00001388H
	jb	SHORT $LN3@vSyncInfoC
$LN11@vSyncInfoC:
	inc	esi
	mov	DWORD PTR [edi+16], esi
	jmp	SHORT $LN1@vSyncInfoC
$LN3@vSyncInfoC:

; 200  : 	else if( ( hBlank - info->hBlank ) >= 5000 ) info->hBlank++;

	mov	ecx, DWORD PTR _hBlank$[esp+52]
	xor	edx, edx
	sub	ecx, eax
	sbb	ebx, edx
	mov	DWORD PTR tv69[esp+56], ebx
	jne	SHORT $LN12@vSyncInfoC
	cmp	ecx, 5000				; 00001388H
	jb	SHORT $LN1@vSyncInfoC
$LN12@vSyncInfoC:
	inc	eax
	mov	DWORD PTR [edi+20], eax
$LN1@vSyncInfoC:

; 201  : 	
; 202  : 	// Calculate accumulative hSync rounding error per half-frame:
; 203  : 	{
; 204  : 	u32 hSyncCycles = ((info->hRender + info->hBlank) * scansPerFrame) / 2;

	mov	eax, DWORD PTR [edi+20]
	add	eax, DWORD PTR [edi+16]

; 205  : 	u32 vSyncCycles = (info->Render + info->Blank);
; 206  : 	info->hSyncError = vSyncCycles - hSyncCycles;

	mov	ecx, DWORD PTR [edi+8]
	imul	eax, DWORD PTR _scansPerFrame$[esp+48]
	shr	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR [edi+4]

; 207  : 	}
; 208  : 
; 209  : 	// Note: In NTSC modes there is some small rounding error in the vsync too,
; 210  : 	// however it would take thousands of frames for it to amount to anything and
; 211  : 	// is thus not worth the effort at this time.
; 212  : }

	pop	esi
	pop	ebp
	mov	DWORD PTR [edi+12], ecx
	pop	ebx
	add	esp, 40					; 00000028H
	ret	0
?vSyncInfoCalc@@YAXPAUvSyncTimingInfo@@II@Z ENDP	; vSyncInfoCalc
; Function compile flags: /Ogtpy
?_rcntSet@@YAXH@Z PROC					; _rcntSet
; _cntidx$ = eax

; 63   : 	s32 c;
; 64   : 	jASSUME( cntidx <= 4 );		// rcntSet isn't valid for h/vsync counters.
; 65   : 
; 66   : 	const Counter& counter = counters[cntidx];

	lea	eax, DWORD PTR [eax+eax*4]

; 67   : 
; 68   : 	// Stopped or special hsync gate?
; 69   : 	if (!counter.mode.IsCounting || (counter.mode.ClockSource == 0x3) ) return;

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[eax*8+4]
	lea	eax, DWORD PTR ?counters@@3PAUCounter@@A[eax*8]
	test	cl, cl
	jns	SHORT $LN6@rcntSet
	and	ecx, 3
	cmp	cl, 3
	je	SHORT $LN6@rcntSet

; 70   : 	
; 71   : 	// check for special cases where the overflow or target has just passed
; 72   : 	// (we probably missed it because we're doing/checking other things)
; 73   : 	if( counter.count > 0x10000 || counter.count > counter.target )

	mov	edx, DWORD PTR [eax]
	cmp	edx, 65536				; 00010000H
	ja	SHORT $LN4@rcntSet
	mov	ecx, DWORD PTR [eax+8]
	cmp	edx, ecx
	ja	SHORT $LN4@rcntSet
	push	ebx

; 76   : 		return;
; 77   : 	}
; 78   : 
; 79   : 	// nextCounter is relative to the cpuRegs.cycle when rcntUpdate() was last called.
; 80   : 	// However, the current _rcntSet could be called at any cycle count, so we need to take
; 81   : 	// that into account.  Adding the difference from that cycle count to the current one
; 82   : 	// will do the trick!
; 83   : 
; 84   : 	c = ((0x10000 - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);
; 85   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();
; 86   : 	if (c < nextCounter) nextCounter = c;

	mov	ebx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	push	ebp
	mov	ebp, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	push	esi
	mov	esi, DWORD PTR [eax+16]
	push	edi
	mov	edi, DWORD PTR [eax+36]
	mov	eax, 65536				; 00010000H
	sub	eax, edx
	imul	eax, esi
	sub	eax, ebp
	add	eax, edi
	cmp	eax, ebx
	jge	SHORT $LN3@rcntSet
	mov	ebx, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN3@rcntSet:

; 87   : 
; 88   : 	// Ignore target diff if target is currently disabled.
; 89   : 	// (the overflow is all we care about since it goes first, and then the 
; 90   : 	// target will be turned on afterward).
; 91   : 
; 92   : 	if( counter.target & EECNT_FUTURE_TARGET ) return;

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN10@rcntSet

; 93   : 	c = ((counter.target - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	sub	ecx, edx
	imul	ecx, esi

; 94   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	ecx, ebp
	add	ecx, edi

; 95   : 	if (c < nextCounter) nextCounter = c;

	cmp	ecx, ebx
	jge	SHORT $LN10@rcntSet
	mov	DWORD PTR ?nextCounter@@3HA, ecx	; nextCounter
$LN10@rcntSet:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN6@rcntSet:

; 96   : }

	ret	0
$LN4@rcntSet:

; 74   : 	{
; 75   : 		nextCounter = 4;

	mov	DWORD PTR ?nextCounter@@3HA, 4		; nextCounter

; 96   : }

	ret	0
?_rcntSet@@YAXH@Z ENDP					; _rcntSet
_TEXT	ENDS
PUBLIC	?rcntReset@@YAXH@Z				; rcntReset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?rcntReset@@YAXH@Z PROC					; rcntReset
; _index$ = eax

; 54   : 	counters[index].count = 0;
; 55   : 	counters[index].sCycleT = cpuRegs.cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A[eax], 0
	mov	DWORD PTR ?counters@@3PAUCounter@@A[eax+36], ecx

; 56   : }

	ret	0
?rcntReset@@YAXH@Z ENDP					; rcntReset
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\savestate.h
_TEXT	ENDS
;	COMDAT ?IsLoading@SaveState@@QBE_NXZ
_TEXT	SEGMENT
?IsLoading@SaveState@@QBE_NXZ PROC			; SaveState::IsLoading, COMDAT
; _this$ = ecx

; 93   : 	bool IsLoading() const { return !IsSaving(); }

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl
	ret	0
?IsLoading@SaveState@@QBE_NXZ ENDP			; SaveState::IsLoading
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetVersion@SaveState@@QBEIXZ
_TEXT	SEGMENT
?GetVersion@SaveState@@QBEIXZ PROC			; SaveState::GetVersion, COMDAT
; _this$ = eax

; 58   : 		// HACK!  Matches the vTLB build versions with VM
; 59   : 		return (m_version & 0xffff) + 0x10;

	movzx	eax, WORD PTR [eax+4]
	add	eax, 16					; 00000010H

; 60   : 	}

	ret	0
?GetVersion@SaveState@@QBEIXZ ENDP			; SaveState::GetVersion
_TEXT	ENDS
PUBLIC	?rcntWtarget@@YIXHI@Z				; rcntWtarget
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\counters.cpp
_TEXT	SEGMENT
?rcntWtarget@@YIXHI@Z PROC				; rcntWtarget
; _index$ = ecx
; _value$ = edx

; 801  : 	EECNT_LOG("EE Counter[%d] writeTarget = %x\n", index, value);
; 802  : 
; 803  : 	counters[index].target = value & 0xffff;

	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	add	ecx, ecx

; 804  : 
; 805  : 	// guard against premature (instant) targeting.
; 806  : 	// If the target is behind the current count, set it up so that the counter must
; 807  : 	// overflow first before the target fires:
; 808  : 
; 809  : 	if( counters[index].target <= rcntCycle(index) )

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+ecx+4]
	add	ecx, ecx
	push	esi
	mov	esi, edx
	and	esi, 65535				; 0000ffffH
	mov	DWORD PTR ?counters@@3PAUCounter@@A[ecx+8], esi
	test	al, al
	jns	SHORT $LN5@rcntWtarge
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN5@rcntWtarge
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+36]
	xor	edx, edx
	div	DWORD PTR ?counters@@3PAUCounter@@A[ecx+16]
	add	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx]
	jmp	SHORT $LN4@rcntWtarge
$LN5@rcntWtarge:
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx]
$LN4@rcntWtarge:
	cmp	esi, eax
	ja	SHORT $LN1@rcntWtarge

; 810  : 		counters[index].target |= EECNT_FUTURE_TARGET;

	or	esi, 268435456				; 10000000H
	mov	DWORD PTR ?counters@@3PAUCounter@@A[ecx+8], esi
$LN1@rcntWtarge:

; 811  : 
; 812  : 	_rcntSet( index );

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+4]
	test	al, al
	jns	SHORT $LN13@rcntWtarge
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN13@rcntWtarge
	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A[ecx]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN11@rcntWtarge
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A[ecx+8]
	cmp	esi, edx
	ja	SHORT $LN11@rcntWtarge
	push	ebx
	mov	ebx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	push	ebp
	mov	ebp, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	push	edi
	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A[ecx+16]
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[ecx+36]
	imul	eax, edi
	sub	eax, ebp
	add	eax, ecx
	cmp	eax, ebx
	jge	SHORT $LN10@rcntWtarge
	mov	ebx, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN10@rcntWtarge:
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN17@rcntWtarge
	sub	edx, esi
	imul	edx, edi
	sub	edx, ebp
	add	edx, ecx
	cmp	edx, ebx
	jge	SHORT $LN17@rcntWtarge
	mov	DWORD PTR ?nextCounter@@3HA, edx	; nextCounter
$LN17@rcntWtarge:
	pop	edi
	pop	ebp
	pop	ebx
$LN13@rcntWtarge:
	pop	esi

; 813  : }

	ret	0

; 811  : 
; 812  : 	_rcntSet( index );

$LN11@rcntWtarge:
	mov	DWORD PTR ?nextCounter@@3HA, 4		; nextCounter
	pop	esi

; 813  : }

	ret	0
?rcntWtarget@@YIXHI@Z ENDP				; rcntWtarget
_TEXT	ENDS
PUBLIC	?rcntWcount@@YIXHI@Z				; rcntWcount
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?rcntWcount@@YIXHI@Z PROC				; rcntWcount
; _index$ = ecx
; _value$ = edx

; 775  : 	EECNT_LOG("EE Counter[%d] writeCount = %x,   oldcount=%x, target=%x\n", index, value, counters[index].count, counters[index].target );
; 776  : 
; 777  : 	counters[index].count = value & 0xffff;

	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	mov	eax, edx
	add	ecx, ecx
	add	ecx, ecx

; 778  : 	
; 779  : 	// reset the target, and make sure we don't get a premature target.
; 780  : 	counters[index].target &= 0xffff;

	xor	edx, edx
	and	eax, 65535				; 0000ffffH
	mov	WORD PTR ?counters@@3PAUCounter@@A[ecx+10], dx

; 781  : 	if( counters[index].count > counters[index].target )

	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A[ecx+8]
	mov	DWORD PTR ?counters@@3PAUCounter@@A[ecx], eax
	cmp	eax, edx
	jbe	SHORT $LN5@rcntWcount

; 782  : 		counters[index].target |= EECNT_FUTURE_TARGET;

	or	edx, 268435456				; 10000000H
	mov	DWORD PTR ?counters@@3PAUCounter@@A[ecx+8], edx
$LN5@rcntWcount:

; 783  : 
; 784  : 	// re-calculate the start cycle of the counter based on elapsed time since the last counter update:
; 785  : 	if(counters[index].mode.IsCounting) {

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+4]
	push	ebx
	push	esi
	push	edi
	test	al, al
	jns	SHORT $LN4@rcntWcount

; 786  : 		if(counters[index].mode.ClockSource != 0x3) {

	and	eax, 3
	cmp	al, 3
	je	SHORT $LN1@rcntWcount

; 787  : 			s32 change = cpuRegs.cycle - counters[index].sCycleT;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	esi, edi
	sub	esi, DWORD PTR ?counters@@3PAUCounter@@A[ecx+36]

; 788  : 			if( change > 0 ) {

	test	esi, esi
	jle	SHORT $LN1@rcntWcount

; 789  : 				change -= (change / counters[index].rate) * counters[index].rate;

	mov	ebx, DWORD PTR ?counters@@3PAUCounter@@A[ecx+16]
	mov	eax, esi
	xor	edx, edx
	div	ebx
	imul	eax, ebx
	sub	esi, eax

; 790  : 				counters[index].sCycleT = cpuRegs.cycle - change;

	sub	edi, esi
	mov	DWORD PTR ?counters@@3PAUCounter@@A[ecx+36], edi

; 791  : 			}
; 792  : 		}
; 793  : 	} 

	jmp	SHORT $LN1@rcntWcount
$LN4@rcntWcount:

; 794  : 	else counters[index].sCycleT = cpuRegs.cycle;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A[ecx+36], eax
$LN1@rcntWcount:

; 795  : 
; 796  : 	_rcntSet( index );

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[ecx+4]
	test	al, al
	jns	SHORT $LN13@rcntWcount
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN13@rcntWcount
	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A[ecx]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN11@rcntWcount
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A[ecx+8]
	cmp	esi, edx
	ja	SHORT $LN11@rcntWcount
	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A[ecx+16]
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[ecx+36]
	mov	ebx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, edi
	push	ebp
	mov	ebp, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	sub	eax, ebp
	add	eax, ecx
	cmp	eax, ebx
	jge	SHORT $LN10@rcntWcount
	mov	ebx, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN10@rcntWcount:
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN17@rcntWcount
	sub	edx, esi
	imul	edx, edi
	sub	edx, ebp
	add	edx, ecx
	cmp	edx, ebx
	jge	SHORT $LN17@rcntWcount
	mov	DWORD PTR ?nextCounter@@3HA, edx	; nextCounter
$LN17@rcntWcount:
	pop	ebp
$LN13@rcntWcount:
	pop	edi
	pop	esi
	pop	ebx

; 797  : }

	ret	0

; 795  : 
; 796  : 	_rcntSet( index );

$LN11@rcntWcount:
	pop	edi
	pop	esi
	mov	DWORD PTR ?nextCounter@@3HA, 4		; nextCounter
	pop	ebx

; 797  : }

	ret	0
?rcntWcount@@YIXHI@Z ENDP				; rcntWcount
; Function compile flags: /Ogtpy
?_rcntSetGate@@YAXH@Z PROC				; _rcntSetGate
; _index$ = esi

; 617  : 	if (counters[index].mode.EnableGate)

	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A[eax+eax+4]
	add	eax, eax
	test	dl, 4
	je	SHORT $LN3@rcntSetGat

; 618  : 	{
; 619  : 		// If the Gate Source is hblank and the clock selection is also hblank
; 620  : 		// then the gate is disabled and the counter acts as a normal hblank source.
; 621  : 
; 622  : 		if( !(counters[index].mode.GateSource == 0 && counters[index].mode.ClockSource == 3) )

	test	dl, 8
	jne	SHORT $LN2@rcntSetGat
	mov	ecx, edx
	and	ecx, 3
	cmp	cl, 3
	je	SHORT $LN3@rcntSetGat
$LN2@rcntSetGat:
	push	edi

; 623  : 		{
; 624  : 			EECNT_LOG( "EE Counter[%d] Using Gate!  Source=%s, Mode=%d.\n",
; 625  : 				index, counters[index].mode.GateSource ? "vblank" : "hblank", counters[index].mode.GateMode );
; 626  : 
; 627  : 			gates |= (1<<index);

	mov	edi, 1
	mov	ecx, esi
	shl	edi, cl

; 628  : 			counters[index].mode.IsCounting = 0;
; 629  : 			rcntReset(index);

	mov	DWORD PTR ?counters@@3PAUCounter@@A[eax], 0
	or	DWORD PTR ?gates@@3HA, edi		; gates
	and	edx, -129				; ffffff7fH
	mov	DWORD PTR ?counters@@3PAUCounter@@A[eax+4], edx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A[eax+36], edx
	pop	edi

; 637  : }

	ret	0
$LN3@rcntSetGat:

; 630  : 			return;
; 631  : 		}
; 632  : 		else
; 633  : 			EECNT_LOG( "EE Counter[%d] GATE DISABLED because of hblank source.\n", index );
; 634  : 	}
; 635  : 
; 636  : 	gates &= ~(1<<index);

	mov	eax, 1
	mov	ecx, esi
	shl	eax, cl
	not	eax
	and	DWORD PTR ?gates@@3HA, eax		; gates

; 637  : }

	ret	0
?_rcntSetGate@@YAXH@Z ENDP				; _rcntSetGate
_TEXT	ENDS
PUBLIC	?frameLimitReset@@YAXXZ				; frameLimitReset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_count$216906 = -12					; size = 8
?frameLimitReset@@YAXXZ PROC				; frameLimitReset

; 349  : {

	sub	esp, 12					; 0000000cH

; 350  : 	m_iStart = GetCPUTicks();

	lea	eax, DWORD PTR _count$216906[esp+12]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	ecx, DWORD PTR _count$216906[esp+12]
	mov	edx, DWORD PTR _count$216906[esp+16]
	mov	DWORD PTR _m_iStart, ecx
	mov	DWORD PTR _m_iStart+4, edx

; 351  : }

	add	esp, 12					; 0000000cH
	ret	0
?frameLimitReset@@YAXXZ ENDP				; frameLimitReset
; Function compile flags: /Ogtpy
?cpuRcntSet@@YAXXZ PROC				; cpuRcntSet

; 101  : 	int i;
; 102  : 
; 103  : 	nextsCounter = cpuRegs.cycle;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	push	ebx
	push	ebp

; 104  : 	nextCounter = (counters[5].sCycle + counters[5].CycleT) - cpuRegs.cycle;

	mov	ebp, DWORD PTR ?counters@@3PAUCounter@@A+232
	sub	ebp, eax
	add	ebp, DWORD PTR ?counters@@3PAUCounter@@A+228
	push	esi
	push	edi
	mov	DWORD PTR ?nextsCounter@@3IA, eax	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
	mov	edx, OFFSET ?counters@@3PAUCounter@@A+8
$LL4@cpuRcntSet:

; 107  : 		_rcntSet( i );

	mov	eax, DWORD PTR [edx-4]
	test	al, al
	jns	SHORT $LN3@cpuRcntSet
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN3@cpuRcntSet
	mov	esi, DWORD PTR [edx-8]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN10@cpuRcntSet
	mov	ecx, DWORD PTR [edx]
	cmp	esi, ecx
	ja	SHORT $LN10@cpuRcntSet
	mov	edi, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx+28]
	mov	ebp, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, edi
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	eax, ebx
	cmp	eax, ebp
	jge	SHORT $LN9@cpuRcntSet
	mov	ebp, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
$LN9@cpuRcntSet:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN3@cpuRcntSet
	sub	ecx, esi
	imul	ecx, edi
	sub	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	ecx, ebx
	cmp	ecx, ebp
	jge	SHORT $LN3@cpuRcntSet
	mov	ebp, ecx
	jmp	SHORT $LN20@cpuRcntSet
$LN10@cpuRcntSet:
	mov	ebp, 4
$LN20@cpuRcntSet:
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
$LN3@cpuRcntSet:

; 105  : 
; 106  : 	for (i = 0; i < 4; i++)

	add	edx, 40					; 00000028H
	cmp	edx, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL4@cpuRcntSet
	pop	edi
	pop	esi

; 108  : 
; 109  : 	// sanity check!
; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	test	ebp, ebp
	pop	ebp
	pop	ebx
	jge	SHORT $LN1@cpuRcntSet
	mov	DWORD PTR ?nextCounter@@3HA, 0		; nextCounter
$LN1@cpuRcntSet:

; 111  : }

	ret	0
?cpuRcntSet@@YAXXZ ENDP					; cpuRcntSet
_TEXT	ENDS
PUBLIC	?rcntWmode@@YIXHI@Z				; rcntWmode
_vSyncInfo DB	01cH DUP (?)
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_index$ = -4						; size = 4
?rcntWmode@@YIXHI@Z PROC				; rcntWmode
; _index$ = ecx
; _value$ = edx

; 743  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 744  : 	if(counters[index].mode.IsCounting) {

	lea	edi, DWORD PTR [ecx+ecx*4]
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[edi+edi+4]
	add	edi, edi
	mov	ebx, edx
	mov	DWORD PTR _index$[esp+20], ecx
	test	al, al
	jns	SHORT $LN10@rcntWmode

; 745  : 		if(counters[index].mode.ClockSource != 0x3) {

	and	eax, 3
	cmp	al, 3
	je	SHORT $LN7@rcntWmode

; 746  : 
; 747  : 			u32 change = cpuRegs.cycle - counters[index].sCycleT;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ebp, esi
	sub	ebp, DWORD PTR ?counters@@3PAUCounter@@A[edi+36]

; 748  : 			if( change > 0 )

	je	SHORT $LN7@rcntWmode

; 749  : 			{
; 750  : 				counters[index].count += change / counters[index].rate;

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[edi+16]
	mov	eax, ebp
	xor	edx, edx
	div	ecx
	add	DWORD PTR ?counters@@3PAUCounter@@A[edi], eax

; 751  : 				change -= (change / counters[index].rate) * counters[index].rate;

	imul	eax, ecx

; 752  : 				counters[index].sCycleT = cpuRegs.cycle - change;
; 753  : 			}
; 754  : 		}
; 755  : 	}

	mov	ecx, DWORD PTR _index$[esp+20]
	sub	ebp, eax
	sub	esi, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+36], esi
	jmp	SHORT $LN7@rcntWmode
$LN10@rcntWmode:

; 756  : 	else counters[index].sCycleT = cpuRegs.cycle;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+36], eax
$LN7@rcntWmode:

; 757  : 
; 758  : 	counters[index].modeval &= ~(value & 0xc00); //Clear status flags, the ps2 only clears what is given in the value

	mov	eax, ebx
	not	eax

; 759  : 	counters[index].modeval = (counters[index].modeval & 0xc00) | (value & 0x3ff);

	and	eax, DWORD PTR ?counters@@3PAUCounter@@A[edi+4]
	and	ebx, 1023				; 000003ffH
	and	eax, 3072				; 00000c00H
	or	eax, ebx
	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+4], eax

; 760  : 	EECNT_LOG("EE Counter[%d] writeMode = %x   passed value=%x\n", index, counters[index].modeval, value );
; 761  : 
; 762  : 	switch (counters[index].mode.ClockSource) { //Clock rate divisers *2, they use BUSCLK speed not PS2CLK

	and	eax, 3
	cmp	eax, 3
	ja	SHORT $LN5@rcntWmode
	jmp	DWORD PTR $LN22@rcntWmode[eax*4]
$LN4@rcntWmode:

; 763  : 		case 0: counters[index].rate = 2; break;

	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+16], 2
	jmp	SHORT $LN5@rcntWmode
$LN3@rcntWmode:

; 764  : 		case 1: counters[index].rate = 32; break;

	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+16], 32 ; 00000020H
	jmp	SHORT $LN5@rcntWmode
$LN2@rcntWmode:

; 765  : 		case 2: counters[index].rate = 512; break;

	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+16], 512 ; 00000200H
	jmp	SHORT $LN5@rcntWmode
$LN1@rcntWmode:

; 766  : 		case 3: counters[index].rate = vSyncInfo.hBlank+vSyncInfo.hRender; break;

	mov	edx, DWORD PTR _vSyncInfo+20
	mov	eax, DWORD PTR _vSyncInfo+16
	add	eax, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A[edi+16], eax
$LN5@rcntWmode:

; 767  : 	}
; 768  : 	
; 769  : 	_rcntSetGate( index );

	mov	esi, ecx
	call	?_rcntSetGate@@YAXH@Z			; _rcntSetGate

; 770  : 	_rcntSet( index );

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[edi+4]
	test	al, al
	jns	SHORT $LN18@rcntWmode
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN18@rcntWmode
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A[edi]
	cmp	edx, 65536				; 00010000H
	ja	SHORT $LN16@rcntWmode
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[edi+8]
	cmp	edx, ecx
	ja	SHORT $LN16@rcntWmode
	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A[edi+16]
	mov	ebp, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A[edi+36]
	mov	ebx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	eax, 65536				; 00010000H
	sub	eax, edx
	imul	eax, esi
	sub	eax, ebp
	add	eax, edi
	cmp	eax, ebx
	jge	SHORT $LN15@rcntWmode
	mov	ebx, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN15@rcntWmode:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN18@rcntWmode
	sub	ecx, edx
	imul	ecx, esi
	sub	ecx, ebp
	add	ecx, edi
	cmp	ecx, ebx
	jge	SHORT $LN18@rcntWmode
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR ?nextCounter@@3HA, ecx	; nextCounter
	pop	ebx

; 771  : }

	pop	ecx
	ret	0

; 770  : 	_rcntSet( index );

$LN16@rcntWmode:
	mov	DWORD PTR ?nextCounter@@3HA, 4		; nextCounter
$LN18@rcntWmode:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 771  : }

	pop	ecx
	ret	0
$LN22@rcntWmode:
	DD	$LN4@rcntWmode
	DD	$LN3@rcntWmode
	DD	$LN2@rcntWmode
	DD	$LN1@rcntWmode
?rcntWmode@@YIXHI@Z ENDP				; rcntWmode
; Function compile flags: /Ogtpy
?_cpuTestOverflow@@YAXH@Z PROC				; _cpuTestOverflow
; _i$ = eax

; 562  : {

	push	esi

; 563  : 	if (counters[i].count <= 0xffff) return;

	lea	esi, DWORD PTR [eax+eax*4]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	cmp	DWORD PTR ?counters@@3PAUCounter@@A[esi], 65535 ; 0000ffffH
	jbe	SHORT $LN3@cpuTestOve

; 564  : 	
; 565  : 	if (counters[i].mode.OverflowInterrupt) {

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[esi+4]
	test	eax, 512				; 00000200H
	je	SHORT $LN5@cpuTestOve

; 566  : 		EECNT_LOG("EE Counter[%d] OVERFLOW - mode=%x, count=%x\n", i, counters[i].mode, counters[i].count);
; 567  : 		counters[i].mode.OverflowReached = 1;
; 568  : 		hwIntcIrq(counters[i].interrupt);

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[esi+20]
	or	eax, 2048				; 00000800H
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR ?counters@@3PAUCounter@@A[esi+4], eax
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN5@cpuTestOve:

; 569  : 	}
; 570  : 	
; 571  : 	// wrap counter back around zero, and enable the future target:
; 572  : 	counters[i].count -= 0x10000;

	add	DWORD PTR ?counters@@3PAUCounter@@A[esi], -65536 ; ffff0000H

; 573  : 	counters[i].target &= 0xffff;

	xor	eax, eax
	mov	WORD PTR ?counters@@3PAUCounter@@A[esi+10], ax
$LN3@cpuTestOve:
	pop	esi

; 574  : }

	ret	0
?_cpuTestOverflow@@YAXH@Z ENDP				; _cpuTestOverflow
; Function compile flags: /Ogtpy
?_cpuTestTarget@@YIXH@Z PROC				; _cpuTestTarget
; _i$ = eax

; 543  : {

	push	esi

; 544  : 	if (counters[i].count < counters[i].target) return;

	lea	esi, DWORD PTR [eax+eax*4]
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[esi+esi+8]
	add	esi, esi
	cmp	DWORD PTR ?counters@@3PAUCounter@@A[esi], ecx
	jb	SHORT $LN1@cpuTestTar

; 545  : 
; 546  : 	if(counters[i].mode.TargetInterrupt) {

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[esi+4]
	test	eax, 256				; 00000100H
	je	SHORT $LN4@cpuTestTar

; 547  : 
; 548  : 		EECNT_LOG("EE Counter[%d] TARGET reached - mode=%x, count=%x, target=%x\n", i, counters[i].mode, counters[i].count, counters[i].target);
; 549  : 		counters[i].mode.TargetReached = 1;
; 550  : 		hwIntcIrq(counters[i].interrupt);

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A[esi+20]
	or	eax, 1024				; 00000400H
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR ?counters@@3PAUCounter@@A[esi+4], eax
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts

; 551  : 
; 552  : 		// The PS2 only resets if the interrupt is enabled - Tested on PS2
; 553  : 		if (counters[i].mode.ZeroReturn)

	test	BYTE PTR ?counters@@3PAUCounter@@A[esi+4], 64 ; 00000040H
	je	SHORT $LN3@cpuTestTar

; 554  : 			counters[i].count -= counters[i].target; // Reset on target

	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A[esi+8]
	sub	DWORD PTR ?counters@@3PAUCounter@@A[esi], eax
	pop	esi

; 559  : }

	ret	0
$LN3@cpuTestTar:

; 555  : 		else
; 556  : 			counters[i].target |= EECNT_FUTURE_TARGET;

	or	DWORD PTR ?counters@@3PAUCounter@@A[esi+8], 268435456 ; 10000000H
	pop	esi

; 559  : }

	ret	0
$LN4@cpuTestTar:

; 557  : 	} 
; 558  : 	else counters[i].target |= EECNT_FUTURE_TARGET;

	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR ?counters@@3PAUCounter@@A[esi+8], ecx
$LN1@cpuTestTar:
	pop	esi

; 559  : }

	ret	0
?_cpuTestTarget@@YIXH@Z ENDP				; _cpuTestTarget
_TEXT	ENDS
PUBLIC	?rcntStartGate@@YIX_NI@Z			; rcntStartGate
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_isVblank$ = 8						; size = 1
_sCycle$ = 12						; size = 4
?rcntStartGate@@YIX_NI@Z PROC				; rcntStartGate

; 641  : {

	push	ebx
	mov	ebx, DWORD PTR _sCycle$[esp]
	push	ebp
	push	esi
	push	edi

; 642  : 	int i;
; 643  : 
; 644  : 	for (i=0; i <=3; i++) {

	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	mov	ebp, 1
	mov	esi, OFFSET ?counters@@3PAUCounter@@A	; counters
	npad	8
$LL33@rcntStartG:

; 645  : 
; 646  : 		//if ((mode == 0) && ((counters[i].mode & 0x83) == 0x83))
; 647  : 		if (!isVblank && counters[i].mode.IsCounting && (counters[i].mode.ClockSource == 3) )

	cmp	BYTE PTR _isVblank$[esp+12], 0
	jne	$LN31@rcntStartG
	mov	eax, DWORD PTR [esi+4]
	test	al, al
	jns	$LN31@rcntStartG
	mov	ecx, eax
	and	ecx, 3
	cmp	cl, 3
	jne	$LN31@rcntStartG

; 648  : 		{
; 649  : 			// Update counters using the hblank as the clock.  This keeps the hblank source
; 650  : 			// nicely in sync with the counters and serves as an optimization also, since these
; 651  : 			// counter won't recieve special rcntUpdate scheduling.
; 652  : 
; 653  : 			// Note: Target and overflow tests must be done here since they won't be done
; 654  : 			// currectly by rcntUpdate (since it's not being scheduled for these counters)
; 655  : 
; 656  : 			counters[i].count += HBLANK_COUNTER_SPEED;

	inc	DWORD PTR [esi]
	mov	edx, DWORD PTR [esi]

; 657  : 			_cpuTestTarget( i );

	mov	ecx, DWORD PTR [esi+8]
	cmp	edx, ecx
	jb	SHORT $LN14@rcntStartG
	test	eax, 256				; 00000100H
	je	SHORT $LN17@rcntStartG
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, 1
	shl	edx, cl
	or	eax, 1024				; 00000400H
	mov	DWORD PTR [esi+4], eax
	or	DWORD PTR [edi+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR [esi+4]
	test	al, 64					; 00000040H
	je	SHORT $LN16@rcntStartG
	mov	ecx, DWORD PTR [esi+8]
	sub	DWORD PTR [esi], ecx
	jmp	SHORT $LN14@rcntStartG
$LN16@rcntStartG:
	or	DWORD PTR [esi+8], 268435456		; 10000000H
	jmp	SHORT $LN14@rcntStartG
$LN17@rcntStartG:
	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR [esi+8], ecx
$LN14@rcntStartG:

; 658  : 			_cpuTestOverflow( i );

	cmp	DWORD PTR [esi], 65535			; 0000ffffH
	jbe	SHORT $LN31@rcntStartG
	test	eax, 512				; 00000200H
	je	SHORT $LN27@rcntStartG
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, 1
	shl	edx, cl
	or	eax, 2048				; 00000800H
	mov	DWORD PTR [esi+4], eax
	or	DWORD PTR [edi+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN27@rcntStartG:
	add	DWORD PTR [esi], -65536			; ffff0000H
	xor	eax, eax
	mov	WORD PTR [esi+10], ax
$LN31@rcntStartG:

; 659  : 		}
; 660  : 
; 661  : 		if (!(gates & (1<<i))) continue;

	mov	ecx, DWORD PTR ?gates@@3HA		; gates
	test	ebp, ecx
	je	SHORT $LN10@rcntStartG

; 662  : 		if ((!!counters[i].mode.GateSource) != isVblank) continue;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, eax
	shr	edx, 3
	and	edx, 1
	cmp	dl, BYTE PTR _isVblank$[esp+12]
	jne	SHORT $LN10@rcntStartG

; 663  : 
; 664  : 		switch (counters[i].mode.GateMode) {

	mov	ecx, eax
	shr	ecx, 4
	and	ecx, 3
	sub	ecx, 0
	je	SHORT $LN3@rcntStartG
	sub	ecx, 1
	je	SHORT $LN1@rcntStartG
	sub	ecx, 2
	jne	SHORT $LN10@rcntStartG
$LN1@rcntStartG:

; 672  : 				EECNT_LOG("EE Counter[%d] %s StartGate Type0, count = %x\n",
; 673  : 					isVblank ? "vblank" : "hblank", i, counters[i].count );
; 674  : 				break;
; 675  : 				
; 676  : 			case 0x2:	// reset and start counting on vsync end
; 677  : 				// this is the vsync start so do nothing.
; 678  : 				break;
; 679  : 				
; 680  : 			case 0x1: //Reset and start counting on Vsync start
; 681  : 			case 0x3: //Reset and start counting on Vsync start and end
; 682  : 				counters[i].mode.IsCounting = 1;

	or	eax, 128				; 00000080H
	mov	DWORD PTR [esi+4], eax

; 683  : 				counters[i].count = 0;
; 684  : 				counters[i].target &= 0xffff;

	xor	eax, eax
	mov	DWORD PTR [esi], 0
	mov	WORD PTR [esi+10], ax

; 685  : 				counters[i].sCycleT = sCycle;
; 686  : 				EECNT_LOG("EE Counter[%d] %s StartGate Type%d, count = %x\n",
; 687  : 					isVblank ? "vblank" : "hblank", i, counters[i].mode.GateMode, counters[i].count );
; 688  : 				break;

	jmp	SHORT $LN34@rcntStartG
$LN3@rcntStartG:

; 665  : 			case 0x0: //Count When Signal is low (off)
; 666  : 			
; 667  : 				// Just set the start cycle (sCycleT) -- counting will be done as needed
; 668  : 				// for events (overflows, targets, mode changes, and the gate off below)
; 669  : 			
; 670  : 				counters[i].mode.IsCounting = 1;

	or	eax, 128				; 00000080H
	mov	DWORD PTR [esi+4], eax
$LN34@rcntStartG:

; 671  : 				counters[i].sCycleT = sCycle;

	mov	DWORD PTR [esi+36], ebx
$LN10@rcntStartG:

; 642  : 	int i;
; 643  : 
; 644  : 	for (i=0; i <=3; i++) {

	add	esi, 40					; 00000028H
	rol	ebp, 1
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+120
	jle	$LL33@rcntStartG
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 689  : 		}
; 690  : 	}
; 691  : 
; 692  : 	// No need to update actual counts here.  Counts are calculated as needed by reads to
; 693  : 	// rcntRcount().  And so long as sCycleT is set properly, any targets or overflows
; 694  : 	// will be scheduled and handled.
; 695  : 
; 696  : 	// Note: No need to set counters here.  They'll get set when control returns to
; 697  : 	// rcntUpdate, since we're being called from there anyway.
; 698  : }

	ret	8
?rcntStartGate@@YIX_NI@Z ENDP				; rcntStartGate
_TEXT	ENDS
PUBLIC	?rcntUpdate_hScanline@@YAXXZ			; rcntUpdate_hScanline
; Function compile flags: /Ogtpy
;	COMDAT ?rcntUpdate_hScanline@@YAXXZ
_TEXT	SEGMENT
?rcntUpdate_hScanline@@YAXXZ PROC			; rcntUpdate_hScanline, COMDAT

; 471  : 	if( !cpuTestCycle( counters[4].sCycle, counters[4].CycleT ) ) return;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	push	edi
	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A+188
	sub	eax, edi
	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+192
	jl	$LN5@rcntUpdate

; 472  : 
; 473  : 	//iopBranchAction = 1;
; 474  : 	if (counters[4].modeval & MODE_HBLANK) { //HBLANK Start

	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	SHORT $LN6@rcntUpdate

; 475  : 		rcntStartGate(false, counters[4].sCycle);

	push	edi
	push	0
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate

; 476  : 		psxCheckStartGate16(0);

	xor	edi, edi
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16

; 477  : 		
; 478  : 		// Setup the hRender's start and end cycle information:
; 479  : 		counters[4].sCycle += vSyncInfo.hBlank;		// start  (absolute cycle value)

	mov	ecx, DWORD PTR _vSyncInfo+20

; 480  : 		counters[4].CycleT = vSyncInfo.hRender;		// endpoint (delta from start value)

	mov	edx, DWORD PTR _vSyncInfo+16
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, edx

; 481  : 		counters[4].modeval = MODE_HRENDER;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, edi

; 493  : 
; 494  : #		ifdef VSYNC_DEBUG
; 495  : 		hsc++;
; 496  : #		endif
; 497  : 	}
; 498  : }

	pop	edi
	ret	0
$LN6@rcntUpdate:

; 482  : 	}
; 483  : 	else { //HBLANK END / HRENDER Begin
; 484  : 		if (CSRw & 0x4) GSCSRr |= 4; // signal

	mov	eax, 4
	test	BYTE PTR ?CSRw@@3IA, al
	je	SHORT $LN4@rcntUpdate
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, eax
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN4@rcntUpdate:

; 485  : 		if (!(GSIMR&0x400)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	jne	SHORT $LN14@rcntUpdate
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 1
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN14@rcntUpdate:

; 486  : 		if (gates) rcntEndGate(false, counters[4].sCycle);

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN2@rcntUpdate
	push	0
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN2@rcntUpdate:

; 487  : 		if (psxhblankgate) psxCheckEndGate16(0);

	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN16@rcntUpdate
	xor	eax, eax
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN16@rcntUpdate:

; 488  : 
; 489  : 		// set up the hblank's start and end cycle information:
; 490  : 		counters[4].sCycle += vSyncInfo.hRender;	// start (absolute cycle value)

	add	edi, DWORD PTR _vSyncInfo+16

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	ecx, DWORD PTR _vSyncInfo+20
	mov	DWORD PTR ?counters@@3PAUCounter@@A+188, edi
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, ecx

; 492  : 		counters[4].modeval = MODE_HBLANK;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 1
$LN5@rcntUpdate:

; 493  : 
; 494  : #		ifdef VSYNC_DEBUG
; 495  : 		hsc++;
; 496  : #		endif
; 497  : 	}
; 498  : }

	pop	edi
	ret	0
?rcntUpdate_hScanline@@YAXXZ ENDP			; rcntUpdate_hScanline
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
_count$805804 = -20					; size = 8
_count$805797 = -20					; size = 8
tv134 = -12						; size = 8
?frameLimit@@YAXXZ PROC					; frameLimit

; 357  : {

	sub	esp, 20					; 00000014H

; 358  : 	s64 sDeltaTime;
; 359  : 	u64 uExpectedEnd;
; 360  : 	u64 iEnd;
; 361  : 
; 362  : 	if( CHECK_FRAMELIMIT == PCSX2_FRAMELIMIT_NORMAL ) return;

	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	push	ebx
	push	ebp
	push	esi
	push	edi
	je	$LN18@frameLimit

; 363  : 	if( Config.CustomFps >= 999 ) return;	// means the user would rather just have framelimiting turned off...

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN18@frameLimit

; 364  : 
; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	esi, DWORD PTR _m_iTicks
	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4

; 366  : 	iEnd = GetCPUTicks();

	lea	eax, DWORD PTR _count$805797[esp+36]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 367  : 
; 368  : 	sDeltaTime = iEnd - uExpectedEnd;
; 369  : 
; 370  : 	// If the framerate drops too low, reset the expected value.  This avoids
; 371  : 	// excessive amounts of "fast forward" syndrome which would occur if we
; 372  : 	// tried to catch up too much.
; 373  : 	
; 374  : 	if( sDeltaTime > m_iTicks*8 )

	mov	ecx, DWORD PTR _m_iTicks+4
	mov	ebp, DWORD PTR _count$805797[esp+36]
	mov	edx, DWORD PTR _m_iTicks
	mov	ebx, DWORD PTR _count$805797[esp+40]
	push	0
	push	8
	push	ecx
	sub	ebp, esi
	push	edx
	sbb	ebx, edi
	call	__allmul
	cmp	ebx, edx
	jl	SHORT $LN3@frameLimit
	jg	SHORT $LN16@frameLimit
	cmp	ebp, eax
	jbe	SHORT $LN3@frameLimit
$LN16@frameLimit:

; 375  : 	{
; 376  : 		m_iStart = iEnd - m_iTicks;

	mov	eax, DWORD PTR _count$805797[esp+36]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$805797[esp+40]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	mov	DWORD PTR _m_iStart+4, ecx

; 377  : 
; 378  : 		// Let the GS Skipper know we lost time.
; 379  : 		// Keeps the GS skipper from trying to catch up to a framerate
; 380  : 		// that the limiter already gave up on.
; 381  : 
; 382  : 		gsSyncLimiterLostTime( (s32)(m_iStart - uExpectedEnd) );

	sub	eax, esi

; 398  : 	}
; 399  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H

; 377  : 
; 378  : 		// Let the GS Skipper know we lost time.
; 379  : 		// Keeps the GS skipper from trying to catch up to a framerate
; 380  : 		// that the limiter already gave up on.
; 381  : 
; 382  : 		gsSyncLimiterLostTime( (s32)(m_iStart - uExpectedEnd) );

	jmp	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
$LN3@frameLimit:

; 383  : 		return;
; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;

	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi

; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	test	ebx, ebx
	jg	SHORT $LN18@frameLimit
	jl	SHORT $LN19@frameLimit
	test	ebp, ebp
	jae	SHORT $LN18@frameLimit
$LN19@frameLimit:
	mov	ebx, DWORD PTR __imp__Sleep@4
$LN2@frameLimit:

; 394  : 	{
; 395  : 		Timeslice();

	push	0
	call	ebx

; 396  : 		iEnd = GetCPUTicks();

	lea	eax, DWORD PTR _count$805804[esp+36]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 397  : 		sDeltaTime = iEnd - uExpectedEnd;

	mov	eax, DWORD PTR _count$805804[esp+36]
	mov	ecx, DWORD PTR _count$805804[esp+40]
	sub	eax, esi
	sbb	ecx, edi
	mov	DWORD PTR tv134[esp+40], ecx
	js	SHORT $LN2@frameLimit

; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	jg	SHORT $LN18@frameLimit
	test	eax, eax
	jb	SHORT $LN2@frameLimit
$LN18@frameLimit:

; 398  : 	}
; 399  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
?frameLimit@@YAXXZ ENDP					; frameLimit
_TEXT	ENDS
PUBLIC	?UpdateVSyncRate@@YAIXZ				; UpdateVSyncRate
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_count$805874 = -8					; size = 8
?UpdateVSyncRate@@YAIXZ PROC				; UpdateVSyncRate

; 216  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8

; 217  : 	const char *limiterMsg = "Framelimiter rate updated (UpdateVSyncRate): %d.%d fps";
; 218  : 
; 219  : 	// fixme - According to some docs, progressive-scan modes actually refresh slower than
; 220  : 	// interlaced modes.  But I can't fathom how, since the refresh rate is a function of
; 221  : 	// the television and all the docs I found on TVs made no indication that they ever
; 222  : 	// run anything except their native refresh rate.
; 223  : 
; 224  : 	//#define VBLANK_NTSC			((Config.PsxType & 2) ? 59.94 : 59.82) //59.94 is more precise
; 225  : 	//#define VBLANK_PAL			((Config.PsxType & 2) ? 50.00 : 49.76)
; 226  : 
; 227  : 	if(Config.PsxType & 1)

	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3584, 1
	push	ebx
	push	ebp
	push	esi

; 228  : 	{
; 229  : 		if( vSyncInfo.Framerate != FRAMERATE_PAL )

	mov	esi, DWORD PTR _vSyncInfo
	push	edi
	je	SHORT $LN8@UpdateVSyn
	cmp	esi, 2500				; 000009c4H
	je	$LN25@UpdateVSyn

; 230  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_PAL, SCANLINES_TOTAL_PAL );

	mov	esi, 2500				; 000009c4H
	mov	DWORD PTR _vSyncInfo+8, 2949120		; 002d0000H
	mov	DWORD PTR _vSyncInfo+20, 9437		; 000024ddH
	mov	DWORD PTR _vSyncInfo+24, 625		; 00000271H
	mov	DWORD PTR _vSyncInfo+4, 2949121		; 002d0001H
	mov	DWORD PTR _vSyncInfo+16, 9438		; 000024deH
	mov	DWORD PTR _vSyncInfo+12, -196		; ffffff3cH

; 231  : 	}
; 232  : 	else

	jmp	SHORT $LN64@UpdateVSyn
$LN8@UpdateVSyn:

; 233  : 	{
; 234  : 		if( vSyncInfo.Framerate != FRAMERATE_NTSC )

	cmp	esi, 2997				; 00000bb5H
	je	SHORT $LN25@UpdateVSyn

; 235  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_NTSC, SCANLINES_TOTAL_NTSC );

	mov	esi, 2997				; 00000bb5H
	mov	DWORD PTR _vSyncInfo+8, 2460060		; 0025899cH
	mov	DWORD PTR _vSyncInfo+20, 9371		; 0000249bH
	mov	DWORD PTR _vSyncInfo+24, 525		; 0000020dH
	mov	DWORD PTR _vSyncInfo+4, 2460061		; 0025899dH
	mov	DWORD PTR _vSyncInfo+16, 9372		; 0000249cH
	mov	DWORD PTR _vSyncInfo+12, 84		; 00000054H
$LN64@UpdateVSyn:
	mov	DWORD PTR _vSyncInfo, esi
$LN25@UpdateVSyn:

; 236  : 	}
; 237  : 
; 238  : 	counters[4].CycleT = vSyncInfo.hRender; // Amount of cycles before the counter will be updated

	mov	eax, DWORD PTR _vSyncInfo+16

; 239  : 	counters[5].CycleT = vSyncInfo.Render; // Amount of cycles before the counter will be updated

	mov	ecx, DWORD PTR _vSyncInfo+4
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, eax

; 240  : 
; 241  : 	if (Config.CustomFps > 0)

	mov	eax, DWORD PTR ?Config@@3UPcsxConfig@@A+3604
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, ecx
	test	eax, eax
	jle	SHORT $LN4@UpdateVSyn

; 242  : 	{
; 243  : 		s64 ticks = GetTickFrequency() / Config.CustomFps;

	cdq
	push	edx
	mov	edx, DWORD PTR _lfreq+4
	push	eax
	mov	eax, DWORD PTR _lfreq
	push	edx
	push	eax
	call	__aulldiv

; 244  : 		if( m_iTicks != ticks )

	mov	ecx, DWORD PTR _m_iTicks
	cmp	ecx, eax
	jne	SHORT $LN58@UpdateVSyn
	mov	ecx, DWORD PTR _m_iTicks+4
	cmp	ecx, edx
	je	$LN1@UpdateVSyn
$LN58@UpdateVSyn:

; 245  : 		{
; 246  : 			m_iTicks = ticks;
; 247  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );

	mov	ecx, DWORD PTR ?mtgsThread@@3PAVmtgsThreadObject@@A ; mtgsThread
	mov	DWORD PTR _m_iTicks, eax
	mov	DWORD PTR _m_iTicks+4, edx
	test	ecx, ecx
	je	SHORT $LN30@UpdateVSyn
	push	0
	push	eax
	push	esi
	push	15					; 0000000fH
	call	?SendSimplePacket@mtgsThreadObject@@QAEXW4GS_RINGTYPE@@HHH@Z ; mtgsThreadObject::SendSimplePacket

; 248  : 			Console::Status( limiterMsg, params Config.CustomFps, 0 );

	mov	edx, DWORD PTR ?Config@@3UPcsxConfig@@A+3604
	push	0

; 249  : 		}
; 250  : 	}
; 251  : 	else

	jmp	$LN65@UpdateVSyn

; 245  : 		{
; 246  : 			m_iTicks = ticks;
; 247  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );

$LN30@UpdateVSyn:
	push	eax
	mov	eax, esi
	call	?_gs_ChangeTimings@@YAXII@Z		; _gs_ChangeTimings

; 248  : 			Console::Status( limiterMsg, params Config.CustomFps, 0 );

	mov	edx, DWORD PTR ?Config@@3UPcsxConfig@@A+3604
	add	esp, 4
	push	0

; 249  : 		}
; 250  : 	}
; 251  : 	else

	jmp	SHORT $LN65@UpdateVSyn
$LN4@UpdateVSyn:

; 252  : 	{
; 253  : 		s64 ticks = (GetTickFrequency() * 50) / vSyncInfo.Framerate;

	mov	eax, DWORD PTR _lfreq+4
	mov	ecx, DWORD PTR _lfreq
	push	0
	push	50					; 00000032H
	push	eax
	push	ecx
	call	__allmul
	push	0
	push	esi
	push	edx
	push	eax
	call	__aulldiv

; 254  : 		if( m_iTicks != ticks )

	mov	ecx, DWORD PTR _m_iTicks
	cmp	ecx, eax
	jne	SHORT $LN59@UpdateVSyn
	mov	ecx, DWORD PTR _m_iTicks+4
	cmp	ecx, edx
	je	SHORT $LN1@UpdateVSyn
$LN59@UpdateVSyn:

; 255  : 		{
; 256  : 			m_iTicks = ticks;
; 257  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );

	mov	ecx, DWORD PTR ?mtgsThread@@3PAVmtgsThreadObject@@A ; mtgsThread
	mov	DWORD PTR _m_iTicks, eax
	mov	DWORD PTR _m_iTicks+4, edx
	test	ecx, ecx
	je	SHORT $LN36@UpdateVSyn
	push	0
	push	eax
	push	esi
	push	15					; 0000000fH
	call	?SendSimplePacket@mtgsThreadObject@@QAEXW4GS_RINGTYPE@@HHH@Z ; mtgsThreadObject::SendSimplePacket
	jmp	SHORT $LN35@UpdateVSyn
$LN36@UpdateVSyn:
	push	eax
	mov	eax, esi
	call	?_gs_ChangeTimings@@YAXII@Z		; _gs_ChangeTimings
	add	esp, 4
$LN35@UpdateVSyn:

; 258  : 			Console::Status( limiterMsg, params vSyncInfo.Framerate/50, (vSyncInfo.Framerate*2)%100 );

	mov	ecx, DWORD PTR _vSyncInfo
	xor	edx, edx
	lea	eax, DWORD PTR [ecx+ecx]
	mov	esi, 100				; 00000064H
	div	esi
	mov	eax, 1374389535				; 51eb851fH
	push	edx
	mul	ecx
	shr	edx, 4
$LN65@UpdateVSyn:
	push	edx
	push	0
	push	OFFSET ??_C@_0DH@NFFNMMLL@Framelimiter?5rate?5updated?5?$CIUpdat@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status
	add	esp, 16					; 00000010H
$LN1@UpdateVSyn:

; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	m_iStart = GetCPUTicks();

	lea	edx, DWORD PTR _count$805874[esp+24]
	push	edx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$805874[esp+24]

; 263  : 	cpuRcntSet();

	mov	ebp, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	ecx, DWORD PTR _count$805874[esp+28]
	mov	DWORD PTR _m_iStart, eax
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	ebp, eax
	add	ebp, DWORD PTR ?counters@@3PAUCounter@@A+232
	mov	DWORD PTR _m_iStart+4, ecx
	mov	DWORD PTR ?nextsCounter@@3IA, eax	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
	mov	edx, OFFSET ?counters@@3PAUCounter@@A+8
$LL44@UpdateVSyn:
	mov	eax, DWORD PTR [edx-4]
	test	al, al
	jns	SHORT $LN43@UpdateVSyn
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN43@UpdateVSyn
	mov	esi, DWORD PTR [edx-8]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN50@UpdateVSyn
	mov	ecx, DWORD PTR [edx]
	cmp	esi, ecx
	ja	SHORT $LN50@UpdateVSyn
	mov	edi, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx+28]
	mov	ebp, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, edi
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	eax, ebx
	cmp	eax, ebp
	jge	SHORT $LN49@UpdateVSyn
	mov	ebp, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
$LN49@UpdateVSyn:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN43@UpdateVSyn
	sub	ecx, esi
	imul	ecx, edi
	sub	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	ecx, ebx
	cmp	ecx, ebp
	jge	SHORT $LN43@UpdateVSyn
	mov	ebp, ecx
	jmp	SHORT $LN66@UpdateVSyn
$LN50@UpdateVSyn:
	mov	ebp, 4
$LN66@UpdateVSyn:
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
$LN43@UpdateVSyn:
	add	edx, 40					; 00000028H
	cmp	edx, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL44@UpdateVSyn
	xor	eax, eax
	cmp	ebp, eax

; 264  : 
; 265  : 	// Initialize VU Skip Stuff...
; 266  : 	g_vu1SkipCount = 0;

	mov	DWORD PTR ?g_vu1SkipCount@@3IA, eax	; g_vu1SkipCount
	jge	SHORT $LN60@UpdateVSyn

; 263  : 	cpuRcntSet();

	mov	DWORD PTR ?nextCounter@@3HA, eax	; nextCounter
$LN60@UpdateVSyn:

; 267  : 
; 268  : 	return (u32)m_iTicks;

	mov	eax, DWORD PTR _m_iTicks

; 269  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateVSyncRate@@YAIXZ ENDP				; UpdateVSyncRate
_TEXT	ENDS
PUBLIC	?rcntInit@@YAXXZ				; rcntInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?rcntInit@@YAXXZ PROC					; rcntInit

; 113  : void rcntInit() {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 114  : 	int i;
; 115  : 
; 116  : 	memzero_obj(counters);

	cld
	mov	ecx, 60					; 0000003cH
	mov	edi, OFFSET ?counters@@3PAUCounter@@A	; counters
	xor	eax, eax
	rep	 stosd

; 117  : 
; 118  : 	for (i=0; i<4; i++) {
; 119  : 		counters[i].rate = 2;
; 120  : 		counters[i].target = 0xffff;

	mov	eax, 65535				; 0000ffffH
	mov	ecx, 2
	mov	DWORD PTR ?counters@@3PAUCounter@@A+8, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+48, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+88, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+128, eax

; 121  : 	}
; 122  : 	counters[0].interrupt =  9;
; 123  : 	counters[1].interrupt = 10;
; 124  : 	counters[2].interrupt = 11;
; 125  : 	counters[3].interrupt = 12;
; 126  : 
; 127  : 	counters[4].modeval = MODE_HRENDER;
; 128  : 	counters[4].sCycle = cpuRegs.cycle;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	xor	ebp, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A+16, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+56, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+96, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+136, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+20, 9
	mov	DWORD PTR ?counters@@3PAUCounter@@A+60, 10 ; 0000000aH
	mov	DWORD PTR ?counters@@3PAUCounter@@A+100, 11 ; 0000000bH
	mov	DWORD PTR ?counters@@3PAUCounter@@A+140, 12 ; 0000000cH
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A+188, eax

; 129  : 	counters[5].modeval = MODE_VRENDER; 

	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, ebp

; 130  : 	counters[5].sCycle = cpuRegs.cycle;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 131  : 
; 132  : 	UpdateVSyncRate();

	call	?UpdateVSyncRate@@YAIXZ			; UpdateVSyncRate

; 133  : 
; 134  : 	for (i=0; i<4; i++) rcntReset(i);

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 135  : 	cpuRcntSet();

	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A+232
	sub	edx, edi
	add	edx, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	DWORD PTR ?counters@@3PAUCounter@@A, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A+36, edi
	mov	DWORD PTR ?counters@@3PAUCounter@@A+40, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A+76, edi
	mov	DWORD PTR ?counters@@3PAUCounter@@A+80, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A+116, edi
	mov	DWORD PTR ?counters@@3PAUCounter@@A+120, ebp
	mov	DWORD PTR ?counters@@3PAUCounter@@A+156, edi
	mov	DWORD PTR ?nextsCounter@@3IA, edi	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, edx	; nextCounter
	mov	esi, OFFSET ?counters@@3PAUCounter@@A+8
$LL35@rcntInit:
	mov	eax, DWORD PTR [esi-4]
	test	al, al
	jns	SHORT $LN34@rcntInit
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN34@rcntInit
	mov	ebx, DWORD PTR [esi-8]
	cmp	ebx, 65536				; 00010000H
	ja	SHORT $LN41@rcntInit
	mov	ecx, DWORD PTR [esi]
	cmp	ebx, ecx
	ja	SHORT $LN41@rcntInit
	mov	ebp, DWORD PTR [esi+8]
	mov	eax, 65536				; 00010000H
	sub	eax, ebx
	imul	eax, ebp
	mov	ebp, DWORD PTR [esi+28]
	sub	eax, edi
	add	eax, ebp
	cmp	eax, edx
	jge	SHORT $LN40@rcntInit
	mov	edx, eax
$LN40@rcntInit:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN61@rcntInit
	sub	ecx, ebx
	imul	ecx, DWORD PTR [esi+8]
	sub	ecx, edi
	add	ecx, ebp
	cmp	ecx, edx
	jge	SHORT $LN61@rcntInit
	mov	edx, ecx
$LN61@rcntInit:
	xor	ebp, ebp
$LN34@rcntInit:
	add	esi, 40					; 00000028H
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL35@rcntInit
	cmp	edx, ebp
	mov	DWORD PTR ?nextCounter@@3HA, edx	; nextCounter
	jge	SHORT $LN32@rcntInit
	mov	DWORD PTR ?nextCounter@@3HA, ebp	; nextCounter
$LN32@rcntInit:

; 136  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN41@rcntInit:

; 135  : 	cpuRcntSet();

	mov	edx, 4
	jmp	SHORT $LN34@rcntInit
?rcntInit@@YAXXZ ENDP					; rcntInit
_TEXT	ENDS
PUBLIC	?rcntFreeze@SaveState@@IAEXXZ			; SaveState::rcntFreeze
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?rcntFreeze@SaveState@@IAEXXZ PROC			; SaveState::rcntFreeze
; _this$ = eax

; 844  : {

	push	esi
	mov	esi, eax

; 845  : 	Freeze(counters);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	240					; 000000f0H
	push	OFFSET ?counters@@3PAUCounter@@A	; counters
	mov	ecx, esi
	call	edx

; 846  : 	Freeze(nextCounter);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	4
	push	OFFSET ?nextCounter@@3HA		; nextCounter
	mov	ecx, esi
	call	edx

; 847  : 	Freeze(nextsCounter);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	push	4
	push	OFFSET ?nextsCounter@@3IA		; nextsCounter
	mov	ecx, esi
	call	edx

; 848  : 
; 849  : 	// New in version 11 -- save the PAL/NTSC info!
; 850  : 	if( GetVersion() > 0x10 )

	movzx	eax, WORD PTR [esi+4]
	add	eax, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jbe	SHORT $LN16@rcntFreeze

; 851  : 	{
; 852  : 		Freeze( Config.PsxType );

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	push	4
	push	OFFSET ?Config@@3UPcsxConfig@@A+3584
	mov	ecx, esi
	call	eax
$LN16@rcntFreeze:

; 853  : 	}
; 854  : 
; 855  : 	if( IsLoading() )

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	test	al, al
	jne	SHORT $LN4@rcntFreeze

; 856  : 	{
; 857  : 		UpdateVSyncRate();

	call	?UpdateVSyncRate@@YAIXZ			; UpdateVSyncRate

; 858  : 
; 859  : 		// make sure the gate flags are set based on the counter modes...
; 860  : 		for( int i=0; i<4; i++ )

	xor	esi, esi
$LL3@rcntFreeze:

; 861  : 			_rcntSetGate( i );

	call	?_rcntSetGate@@YAXH@Z			; _rcntSetGate
	inc	esi
	cmp	esi, 4
	jl	SHORT $LL3@rcntFreeze

; 862  : 
; 863  : 		iopBranchAction = 1;	// probably not needed but won't hurt anything either.

	mov	BYTE PTR ?iopBranchAction@@3_NA, 1	; iopBranchAction
$LN4@rcntFreeze:

; 864  : 	}
; 865  : }

	pop	esi
	ret	0
?rcntFreeze@SaveState@@IAEXXZ ENDP			; SaveState::rcntFreeze
; Function compile flags: /Ogtpy
_count$812571 = -16					; size = 8
_count$812566 = -16					; size = 8
_result$812511 = -16					; size = 4
tv195 = -8						; size = 8
_sCycle$ = 8						; size = 4
?VSyncEnd@@YAXI@Z PROC					; VSyncEnd

; 437  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC END  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );
; 438  : 
; 439  : 	iFrame++;

	inc	DWORD PTR _iFrame
	sub	esp, 16					; 00000010H

; 440  : 
; 441  : 	if( g_vu1SkipCount > 0 )

	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	push	ebx
	push	ebp
	push	esi
	push	edi
	jbe	SHORT $LN3@VSyncEnd

; 442  : 	{
; 443  : 		gsPostVsyncEnd( false );

	push	0
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4

; 444  : 		AtomicDecrement( g_vu1SkipCount );

	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount
	mov	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	DWORD PTR _result$812511[esp+32], eax

; 445  : 		vu1MicroEnableSkip();

	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block

; 446  : 	}
; 447  : 	else

	jmp	SHORT $LN17@VSyncEnd
$LN3@VSyncEnd:

; 448  : 	{
; 449  : 		gsPostVsyncEnd( true );

	push	1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4

; 450  : 		vu1MicroDisableSkip();

	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN16@VSyncEnd
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	je	SHORT $LN16@VSyncEnd
	mov	eax, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
	jmp	SHORT $LN17@VSyncEnd
$LN16@VSyncEnd:
	mov	ecx, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, ecx
$LN17@VSyncEnd:

; 451  : 	}
; 452  : 
; 453  : 	hwIntcIrq(INTC_VBLANK_E);  // HW Irq

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 8
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts

; 454  : 	psxVBlankEnd(); // psxCounters vBlank End

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	mov	bl, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	or	DWORD PTR [eax+4208], 2048		; 00000800H
	test	bl, 2
	je	SHORT $LN24@VSyncEnd
	mov	eax, 1
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN24@VSyncEnd:
	test	bl, 8
	je	SHORT $LN26@VSyncEnd
	mov	eax, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN26@VSyncEnd:

; 455  : 	if (gates) rcntEndGate(true, sCycle); // Counters End Gate Code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN1@VSyncEnd
	mov	edi, DWORD PTR _sCycle$[esp+28]
	push	1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
$LN1@VSyncEnd:

; 456  : 	frameLimit(); // limit FPS

	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN45@VSyncEnd
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN45@VSyncEnd
	mov	esi, DWORD PTR _m_iTicks
	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
	lea	edx, DWORD PTR _count$812566[esp+32]
	push	edx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _m_iTicks+4
	mov	ebp, DWORD PTR _count$812566[esp+32]
	mov	ecx, DWORD PTR _m_iTicks
	mov	ebx, DWORD PTR _count$812566[esp+36]
	push	0
	push	8
	push	eax
	sub	ebp, esi
	push	ecx
	sbb	ebx, edi
	call	__allmul
	cmp	ebx, edx
	jl	SHORT $LN30@VSyncEnd
	jg	SHORT $LN43@VSyncEnd
	cmp	ebp, eax
	jbe	SHORT $LN30@VSyncEnd
$LN43@VSyncEnd:
	mov	eax, DWORD PTR _count$812566[esp+32]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$812566[esp+36]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	mov	DWORD PTR _m_iStart+4, ecx
	sub	eax, esi

; 457  : 
; 458  : 	// This doesn't seem to be needed here.  Games only seem to break with regard to the
; 459  : 	// vsyncstart irq. 
; 460  : 	//cpuRegs.eCycle[30] = 2;
; 461  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H

; 456  : 	frameLimit(); // limit FPS

	jmp	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
$LN30@VSyncEnd:
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	test	ebx, ebx
	jg	SHORT $LN45@VSyncEnd
	jl	SHORT $LN46@VSyncEnd
	test	ebp, ebp
	jae	SHORT $LN45@VSyncEnd
$LN46@VSyncEnd:
	mov	ebx, DWORD PTR __imp__Sleep@4
$LN29@VSyncEnd:
	push	0
	call	ebx
	lea	edx, DWORD PTR _count$812571[esp+32]
	push	edx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$812571[esp+32]
	mov	ecx, DWORD PTR _count$812571[esp+36]
	sub	eax, esi
	sbb	ecx, edi
	mov	DWORD PTR tv195[esp+36], ecx
	js	SHORT $LN29@VSyncEnd
	jg	SHORT $LN45@VSyncEnd
	test	eax, eax
	jb	SHORT $LN29@VSyncEnd
$LN45@VSyncEnd:

; 457  : 
; 458  : 	// This doesn't seem to be needed here.  Games only seem to break with regard to the
; 459  : 	// vsyncstart irq. 
; 460  : 	//cpuRegs.eCycle[30] = 2;
; 461  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
?VSyncEnd@@YAXI@Z ENDP					; VSyncEnd
; Function compile flags: /Ogtpy
_sCycle$ = 8						; size = 4
?VSyncStart@@YAXI@Z PROC				; VSyncStart

; 402  : {

	push	ecx
	push	ebx

; 403  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC START  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );
; 404  : 	vSyncDebugStuff(); // EE Profiling and Debug code
; 405  : 
; 406  : 	if ((CSRw & 0x8)) GSCSRr|= 0x8;

	mov	ebx, 8
	push	esi
	push	edi
	test	BYTE PTR ?CSRw@@3IA, bl
	je	SHORT $LN4@VSyncStart
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, ebx
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN4@VSyncStart:

; 407  : 	if (!(GSIMR&0x800)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	edi, 1
	jne	SHORT $LN11@VSyncStart
	or	DWORD PTR [esi+61440], edi
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN11@VSyncStart:

; 408  : 
; 409  : 	hwIntcIrq(INTC_VBLANK_S);

	or	DWORD PTR [esi+61440], 4
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts

; 410  : 	psxVBlankStart();

	call	?cdvdVsync@@YAXXZ			; cdvdVsync
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], edi
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN16@VSyncStart
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
$LN16@VSyncStart:
	test	BYTE PTR ?psxvblankgate@@3EA, bl	; psxvblankgate
	je	SHORT $LN36@VSyncStart
	mov	eax, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
$LN36@VSyncStart:

; 411  : 
; 412  : 	if (gates) rcntStartGate(true, sCycle); // Counters Start Gate code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN2@VSyncStart
	mov	ecx, DWORD PTR _sCycle$[esp+12]
	push	ecx
	push	edi
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
$LN2@VSyncStart:

; 413  : 	if (Config.Patch) applypatch(1); // Apply patches (ToDo: clean up patch code)

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN38@VSyncStart
	xor	ebx, ebx
	cmp	DWORD PTR ?patchnumber@@3HA, ebx	; patchnumber
	jle	SHORT $LN38@VSyncStart
	mov	esi, OFFSET ?patch@@3PAUIniPatch@@A	; patch
	npad	5
$LL40@VSyncStart:
	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN39@VSyncStart
	mov	eax, esi
	call	?_applypatch@@YAXHPAUIniPatch@@@Z	; _applypatch
$LN39@VSyncStart:
	add	ebx, edi
	add	esi, 32					; 00000020H
	cmp	ebx, DWORD PTR ?patchnumber@@3HA	; patchnumber
	jl	SHORT $LL40@VSyncStart
$LN38@VSyncStart:

; 414  : 
; 415  : 	// INTC - VB Blank Start Hack --
; 416  : 	// Hack fix!  This corrects a freezeup in Granda 2 where it decides to spin
; 417  : 	// on the INTC_STAT register after the exception handler has already cleared
; 418  : 	// it.  But be warned!  Set the value to larger than 4 and it breaks Dark
; 419  : 	// Cloud and other games. -_-
; 420  : 
; 421  : 	// How it works: Normally the INTC raises exceptions immediately at the end of the
; 422  : 	// current branch test.  But in the case of Grandia 2, the game's code is spinning
; 423  : 	// on the INTC status, and the exception handler (for some reason?) clears the INTC
; 424  : 	// before returning *and* returns to a location other than EPC.  So the game never
; 425  : 	// gets to the point where it sees the INTC Irq set true.
; 426  : 
; 427  : 	// (I haven't investigated why Dark Cloud freezes on larger values)
; 428  : 	// (all testing done using the recompiler -- dunno how the ints respond yet)
; 429  : 
; 430  : 	//cpuRegs.eCycle[30] = 2;
; 431  : 
; 432  : 	// Should no longer be required (Refraction)
; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	0
?VSyncStart@@YAXI@Z ENDP				; VSyncStart
_TEXT	ENDS
PUBLIC	?rcntUpdate_vSync@@YA_NXZ			; rcntUpdate_vSync
; Function compile flags: /Ogtpy
;	COMDAT ?rcntUpdate_vSync@@YA_NXZ
_TEXT	SEGMENT
_count$856964 = -20					; size = 8
_count$856959 = -20					; size = 8
_result$856929 = -20					; size = 4
tv468 = -12						; size = 8
?rcntUpdate_vSync@@YA_NXZ PROC				; rcntUpdate_vSync, COMDAT

; 502  : 	s32 diff = (cpuRegs.cycle - counters[5].sCycle);

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+228
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	sub	ecx, eax

; 503  : 	if( diff < counters[5].CycleT ) return false;

	cmp	ecx, DWORD PTR ?counters@@3PAUCounter@@A+232
	push	esi
	push	edi
	jl	$LN127@rcntUpdate@2

; 504  : 
; 505  : 	//iopBranchAction = 1;
; 506  : 	if (counters[5].modeval == MODE_VSYNC)

	mov	ebp, 3
	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, ebp
	jne	$LN2@rcntUpdate@2

; 507  : 	{
; 508  : 		VSyncEnd(counters[5].sCycle);

	inc	DWORD PTR _iFrame
	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	mov	edi, eax
	jbe	SHORT $LN8@rcntUpdate@2
	push	0
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount
	mov	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	DWORD PTR _result$856929[esp+36], eax
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
	jmp	SHORT $LN22@rcntUpdate@2
$LN8@rcntUpdate@2:
	push	1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN21@rcntUpdate@2
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	je	SHORT $LN21@rcntUpdate@2
	mov	edx, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, edx
	jmp	SHORT $LN22@rcntUpdate@2
$LN21@rcntUpdate@2:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN22@rcntUpdate@2:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 8
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	mov	bl, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	or	DWORD PTR [eax+4208], 2048		; 00000800H
	test	bl, 2
	je	SHORT $LN29@rcntUpdate@2
	mov	eax, 1
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN29@rcntUpdate@2:
	test	bl, 8
	je	SHORT $LN31@rcntUpdate@2
	mov	eax, ebp
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN31@rcntUpdate@2:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN6@rcntUpdate@2
	push	1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
$LN6@rcntUpdate@2:
	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN122@rcntUpdate@2
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN122@rcntUpdate@2
	mov	esi, DWORD PTR _m_iTicks
	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
	lea	ecx, DWORD PTR _count$856959[esp+36]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	edx, DWORD PTR _m_iTicks+4
	mov	ebx, DWORD PTR _count$856959[esp+36]
	mov	eax, DWORD PTR _m_iTicks
	mov	ebp, DWORD PTR _count$856959[esp+40]
	push	0
	push	8
	push	edx
	sub	ebx, esi
	push	eax
	sbb	ebp, edi
	call	__allmul
	cmp	ebp, edx
	jl	SHORT $LN35@rcntUpdate@2
	jg	SHORT $LN120@rcntUpdate@2
	cmp	ebx, eax
	jbe	SHORT $LN35@rcntUpdate@2
$LN120@rcntUpdate@2:
	mov	eax, DWORD PTR _count$856959[esp+36]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$856959[esp+40]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	sub	eax, esi
	mov	DWORD PTR _m_iStart+4, ecx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
	jmp	SHORT $LN122@rcntUpdate@2
$LN35@rcntUpdate@2:
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	test	ebp, ebp
	jg	SHORT $LN122@rcntUpdate@2
	jl	SHORT $LN123@rcntUpdate@2
	test	ebx, ebx
	jae	SHORT $LN122@rcntUpdate@2
$LN123@rcntUpdate@2:
	mov	ebx, DWORD PTR __imp__Sleep@4
$LL34@rcntUpdate@2:
	push	0
	call	ebx
	lea	ecx, DWORD PTR _count$856964[esp+36]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$856964[esp+36]
	mov	edx, DWORD PTR _count$856964[esp+40]
	sub	eax, esi
	sbb	edx, edi
	mov	DWORD PTR tv468[esp+40], edx
	js	SHORT $LL34@rcntUpdate@2
	jg	SHORT $LN122@rcntUpdate@2
	test	eax, eax
	jb	SHORT $LL34@rcntUpdate@2
$LN122@rcntUpdate@2:

; 509  : 
; 510  : 		counters[5].sCycle += vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8

; 511  : 		counters[5].CycleT = vSyncInfo.Render;

	mov	ecx, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, ecx

; 512  : 		counters[5].modeval = MODE_VRENDER;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0

; 513  : 
; 514  : 		return true;

	mov	al, 1

; 527  : 
; 528  : #		ifdef VSYNC_DEBUG
; 529  : 		vblankinc++;
; 530  : 		if( vblankinc > 1 )
; 531  : 		{
; 532  : 			if( hsc != vSyncInfo.hScanlinesPerFrame )
; 533  : 				SysPrintf( " ** vSync > Abnormal Scanline Count: %d\n", hsc );
; 534  : 			hsc = 0;
; 535  : 			vblankinc = 0;
; 536  : 		}
; 537  : #		endif
; 538  : 	}
; 539  : 	return false;
; 540  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@rcntUpdate@2:

; 515  : //		SysUpdate();  // check for and handle keyevents
; 516  : 	}
; 517  : 	else	// VSYNC end / VRENDER begin
; 518  : 	{
; 519  : 		VSyncStart(counters[5].sCycle);

	test	BYTE PTR ?CSRw@@3IA, 8
	mov	ebx, eax
	je	SHORT $LN49@rcntUpdate@2
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, edx
$LN49@rcntUpdate@2:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	edi, 1
	jne	SHORT $LN56@rcntUpdate@2
	or	DWORD PTR [esi+61440], edi
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN56@rcntUpdate@2:
	or	DWORD PTR [esi+61440], 4
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	call	?cdvdVsync@@YAXXZ			; cdvdVsync
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], edi
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN61@rcntUpdate@2
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
$LN61@rcntUpdate@2:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN81@rcntUpdate@2
	mov	eax, ebp
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
$LN81@rcntUpdate@2:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN47@rcntUpdate@2
	push	ebx
	push	edi
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
$LN47@rcntUpdate@2:
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN83@rcntUpdate@2
	xor	ebx, ebx
	cmp	DWORD PTR ?patchnumber@@3HA, ebx	; patchnumber
	jle	SHORT $LN83@rcntUpdate@2
	mov	esi, OFFSET ?patch@@3PAUIniPatch@@A	; patch
$LL85@rcntUpdate@2:
	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN84@rcntUpdate@2
	mov	eax, esi
	call	?_applypatch@@YAXHPAUIniPatch@@@Z	; _applypatch
$LN84@rcntUpdate@2:
	add	ebx, edi
	add	esi, 32					; 00000020H
	cmp	ebx, DWORD PTR ?patchnumber@@3HA	; patchnumber
	jl	SHORT $LL85@rcntUpdate@2
$LN83@rcntUpdate@2:

; 520  : 
; 521  : 		counters[5].sCycle += vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4

; 522  : 		counters[5].CycleT = vSyncInfo.Blank;

	mov	ecx, DWORD PTR _vSyncInfo+8

; 523  : 		counters[5].modeval = MODE_VSYNC;
; 524  : 
; 525  : 		// Accumulate hsync rounding errors:
; 526  : 		counters[4].sCycle += vSyncInfo.hSyncError;

	mov	edx, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, ebp
$LN127@rcntUpdate@2:

; 527  : 
; 528  : #		ifdef VSYNC_DEBUG
; 529  : 		vblankinc++;
; 530  : 		if( vblankinc > 1 )
; 531  : 		{
; 532  : 			if( hsc != vSyncInfo.hScanlinesPerFrame )
; 533  : 				SysPrintf( " ** vSync > Abnormal Scanline Count: %d\n", hsc );
; 534  : 			hsc = 0;
; 535  : 			vblankinc = 0;
; 536  : 		}
; 537  : #		endif
; 538  : 	}
; 539  : 	return false;
; 540  : }

	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
?rcntUpdate_vSync@@YA_NXZ ENDP				; rcntUpdate_vSync
_TEXT	ENDS
PUBLIC	?rcntUpdate@@YA_NXZ				; rcntUpdate
; Function compile flags: /Ogtpy
;	COMDAT ?rcntUpdate@@YA_NXZ
_TEXT	SEGMENT
_retval$ = -29						; size = 1
_count$858696 = -28					; size = 8
_result$858664 = -28					; size = 4
_count$858701 = -20					; size = 8
_sDeltaTime$858685 = -12				; size = 8
?rcntUpdate@@YA_NXZ PROC				; rcntUpdate, COMDAT

; 582  : 	bool retval = rcntUpdate_vSync();

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+228
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	sub	eax, ecx
	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	push	esi
	push	edi
	jge	SHORT $LN12@rcntUpdate@3
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
	jmp	$LN178@rcntUpdate@3
$LN12@rcntUpdate@3:
	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	jne	$LN11@rcntUpdate@3
	inc	DWORD PTR _iFrame
	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	mov	edi, ecx
	jbe	SHORT $LN17@rcntUpdate@3
	push	0
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount
	mov	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	DWORD PTR _result$858664[esp+52], eax
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
	jmp	SHORT $LN31@rcntUpdate@3
$LN17@rcntUpdate@3:
	push	1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN30@rcntUpdate@3
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	je	SHORT $LN30@rcntUpdate@3
	mov	eax, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
	jmp	SHORT $LN31@rcntUpdate@3
$LN30@rcntUpdate@3:
	mov	ecx, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, ecx
$LN31@rcntUpdate@3:
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [ebp+61440], 8
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	mov	bl, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	or	DWORD PTR [eax+4208], 2048		; 00000800H
	test	bl, 2
	je	SHORT $LN38@rcntUpdate@3
	mov	eax, 1
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN38@rcntUpdate@3:
	test	bl, 8
	je	SHORT $LN40@rcntUpdate@3
	mov	eax, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN40@rcntUpdate@3:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN15@rcntUpdate@3
	push	1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
$LN15@rcntUpdate@3:
	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN165@rcntUpdate@3
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN165@rcntUpdate@3
	mov	esi, DWORD PTR _m_iTicks
	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
	lea	edx, DWORD PTR _count$858696[esp+52]
	push	edx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _m_iTicks+4
	mov	ebx, DWORD PTR _count$858696[esp+52]
	mov	ecx, DWORD PTR _m_iTicks
	mov	ebp, DWORD PTR _count$858696[esp+56]
	push	0
	push	8
	push	eax
	sub	ebx, esi
	push	ecx
	sbb	ebp, edi
	call	__allmul
	cmp	ebp, edx
	jl	SHORT $LN44@rcntUpdate@3
	jg	SHORT $LN163@rcntUpdate@3
	cmp	ebx, eax
	jbe	SHORT $LN44@rcntUpdate@3
$LN163@rcntUpdate@3:
	mov	eax, DWORD PTR _count$858696[esp+52]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$858696[esp+56]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	sub	eax, esi
	mov	DWORD PTR _m_iStart+4, ecx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
	jmp	SHORT $LN171@rcntUpdate@3
$LN44@rcntUpdate@3:
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	test	ebp, ebp
	jg	SHORT $LN171@rcntUpdate@3
	jl	SHORT $LN166@rcntUpdate@3
	test	ebx, ebx
	jae	SHORT $LN171@rcntUpdate@3
$LN166@rcntUpdate@3:
	mov	ebx, DWORD PTR __imp__Sleep@4
$LN43@rcntUpdate@3:
	push	0
	call	ebx
	lea	edx, DWORD PTR _count$858701[esp+52]
	push	edx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$858701[esp+52]
	mov	ecx, DWORD PTR _count$858701[esp+56]
	sub	eax, esi
	sbb	ecx, edi
	mov	DWORD PTR _sDeltaTime$858685[esp+56], ecx
	js	SHORT $LN43@rcntUpdate@3
	jg	SHORT $LN171@rcntUpdate@3
	test	eax, eax
	jb	SHORT $LN43@rcntUpdate@3
$LN171@rcntUpdate@3:
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
$LN165@rcntUpdate@3:
	mov	edx, DWORD PTR _vSyncInfo+8
	mov	eax, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0
	mov	BYTE PTR _retval$[esp+52], 1
	jmp	$LN13@rcntUpdate@3
$LN11@rcntUpdate@3:
	test	BYTE PTR ?CSRw@@3IA, 8
	mov	esi, ecx
	je	SHORT $LN58@rcntUpdate@3
	mov	ecx, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, ecx
$LN58@rcntUpdate@3:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
	mov	edi, 1
	jne	SHORT $LN65@rcntUpdate@3
	or	DWORD PTR [ebp+61440], edi
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN65@rcntUpdate@3:
	or	DWORD PTR [ebp+61440], 4
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	call	?cdvdVsync@@YAXXZ			; cdvdVsync
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], edi
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN70@rcntUpdate@3
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
$LN70@rcntUpdate@3:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN90@rcntUpdate@3
	mov	eax, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
$LN90@rcntUpdate@3:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN56@rcntUpdate@3
	push	esi
	push	edi
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
$LN56@rcntUpdate@3:
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN92@rcntUpdate@3
	xor	ebx, ebx
	cmp	DWORD PTR ?patchnumber@@3HA, ebx	; patchnumber
	jle	SHORT $LN92@rcntUpdate@3
	mov	esi, OFFSET ?patch@@3PAUIniPatch@@A	; patch
$LL94@rcntUpdate@3:
	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN93@rcntUpdate@3
	mov	eax, esi
	call	?_applypatch@@YAXHPAUIniPatch@@@Z	; _applypatch
$LN93@rcntUpdate@3:
	add	ebx, edi
	add	esi, 32					; 00000020H
	cmp	ebx, DWORD PTR ?patchnumber@@3HA	; patchnumber
	jl	SHORT $LL94@rcntUpdate@3
	mov	ebp, DWORD PTR ?psH@@3PAEA		; psH
$LN92@rcntUpdate@3:
	mov	edx, DWORD PTR _vSyncInfo+4
	mov	eax, DWORD PTR _vSyncInfo+8
	mov	ecx, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, edx
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
$LN178@rcntUpdate@3:
	mov	BYTE PTR _retval$[esp+52], 0
$LN13@rcntUpdate@3:

; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	mov	esi, OFFSET ?counters@@3PAUCounter@@A+4
$LL7@rcntUpdate@3:

; 587  : 		
; 588  : 		// We want to count gated counters (except the hblank which exclude below, and are
; 589  : 		// counted by the hblank timer instead)
; 590  : 
; 591  : 		//if ( gates & (1<<i) ) continue;
; 592  : 		
; 593  : 		if (!counters[i].mode.IsCounting ) continue;

	mov	ecx, DWORD PTR [esi]
	test	cl, cl
	jns	$LN6@rcntUpdate@3

; 594  : 
; 595  : 		if(counters[i].mode.ClockSource != 0x3)	// don't count hblank sources

	mov	edx, ecx
	and	edx, 3
	cmp	dl, 3
	je	$LN3@rcntUpdate@3

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	edi, DWORD PTR [esi+32]

; 598  : 			if( change < 0 ) change = 0;	// sanity check!

	jns	SHORT $LN2@rcntUpdate@3
	xor	edi, edi
$LN2@rcntUpdate@3:

; 599  : 
; 600  : 			counters[i].count += change / counters[i].rate;

	mov	ebx, DWORD PTR [esi+12]
	mov	eax, edi
	xor	edx, edx
	div	ebx
	add	DWORD PTR [esi-4], eax

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	imul	eax, ebx
	sub	edi, eax

; 602  : 			counters[i].sCycleT = cpuRegs.cycle - change;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	eax, edi
	mov	DWORD PTR [esi+32], eax

; 603  : 
; 604  : 			// Check Counter Targets and Overflows:
; 605  : 			_cpuTestTarget( i );

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi-4], eax
	jb	SHORT $LN125@rcntUpdate@3
	test	ecx, 256				; 00000100H
	je	SHORT $LN128@rcntUpdate@3
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, 1
	shl	edx, cl
	or	DWORD PTR [ebp+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ecx, DWORD PTR [esi]
	test	cl, 64					; 00000040H
	je	SHORT $LN127@rcntUpdate@3
	mov	eax, DWORD PTR [esi+4]
	sub	DWORD PTR [esi-4], eax
	jmp	SHORT $LN125@rcntUpdate@3
$LN127@rcntUpdate@3:
	or	DWORD PTR [esi+4], 268435456		; 10000000H
	jmp	SHORT $LN125@rcntUpdate@3
$LN128@rcntUpdate@3:
	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [esi+4], eax
$LN125@rcntUpdate@3:

; 606  : 			_cpuTestOverflow( i );

	cmp	DWORD PTR [esi-4], 65535		; 0000ffffH
	jbe	SHORT $LN6@rcntUpdate@3
	test	ecx, 512				; 00000200H
	je	SHORT $LN138@rcntUpdate@3
	or	ecx, 2048				; 00000800H
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, 1
	shl	edx, cl
	or	DWORD PTR [ebp+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN138@rcntUpdate@3:
	add	DWORD PTR [esi-4], -65536		; ffff0000H
	xor	eax, eax
	mov	WORD PTR [esi+6], ax
	jmp	SHORT $LN6@rcntUpdate@3
$LN3@rcntUpdate@3:

; 607  : 		} 
; 608  : 		else counters[i].sCycleT = cpuRegs.cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR [esi+32], ecx
$LN6@rcntUpdate@3:
	add	esi, 40					; 00000028H
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LL7@rcntUpdate@3

; 609  : 	}
; 610  : 
; 611  : 	cpuRcntSet();

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ebx, DWORD PTR ?counters@@3PAUCounter@@A+232
	sub	ebx, eax
	add	ebx, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	DWORD PTR ?nextsCounter@@3IA, eax	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
	mov	edx, OFFSET ?counters@@3PAUCounter@@A+8
	npad	5
$LL143@rcntUpdate@3:
	mov	eax, DWORD PTR [edx-4]
	test	al, al
	jns	SHORT $LN142@rcntUpdate@3
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN142@rcntUpdate@3
	mov	esi, DWORD PTR [edx-8]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN149@rcntUpdate@3
	mov	ecx, DWORD PTR [edx]
	cmp	esi, ecx
	ja	SHORT $LN149@rcntUpdate@3
	mov	edi, DWORD PTR [edx+8]
	mov	ebp, DWORD PTR [edx+28]
	mov	ebx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, edi
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	eax, ebp
	cmp	eax, ebx
	jge	SHORT $LN148@rcntUpdate@3
	mov	ebx, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN148@rcntUpdate@3:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN142@rcntUpdate@3
	sub	ecx, esi
	imul	ecx, edi
	sub	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	ecx, ebp
	cmp	ecx, ebx
	jge	SHORT $LN142@rcntUpdate@3
	mov	ebx, ecx
	jmp	SHORT $LN179@rcntUpdate@3
$LN149@rcntUpdate@3:
	mov	ebx, 4
$LN179@rcntUpdate@3:
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN142@rcntUpdate@3:
	add	edx, 40					; 00000028H
	cmp	edx, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL143@rcntUpdate@3

; 612  : 	return retval;

	mov	al, BYTE PTR _retval$[esp+52]
	test	ebx, ebx
	jge	SHORT $LN140@rcntUpdate@3

; 609  : 	}
; 610  : 
; 611  : 	cpuRcntSet();

	mov	DWORD PTR ?nextCounter@@3HA, 0		; nextCounter
$LN140@rcntUpdate@3:

; 613  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
?rcntUpdate@@YA_NXZ ENDP				; rcntUpdate
_TEXT	ENDS
END
